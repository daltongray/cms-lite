/**
 * anime.js - UMD
 * @version v4.0.0-beta.100.alpha-4
 * @author Julian Garnier
 * @license MIT
 * @copyright (c) 2024 Julian Garnier
 * @see animejs.com
 */
(function(global,factory){typeof exports==="object"&&typeof module!=="undefined"?factory(exports):typeof define==="function"&&define.amd?define(["exports"],factory):(global=typeof globalThis!=="undefined"?globalThis:global||self,factory(global.anime={}))})(this,(function(exports){"use strict";const isBrowser=typeof window!=="undefined";const win=isBrowser?window:null;const doc=isBrowser?document:null;const tweenTypes={INVALID:0,OBJECT:1,ATTRIBUTE:2,CSS:3,TRANSFORM:4,CSS_VAR:5};const valueTypes={NUMBER:0,UNIT:1,COLOR:2,COMPLEX:3};const tickModes={NONE:0,AUTO:1,FORCE:2};const compositionTypes={replace:0,none:1,blend:2};const isRegisteredTargetSymbol=Symbol();const isDomSymbol=Symbol();const isSvgSymbol=Symbol();const transformsSymbol=Symbol();const morphPointsSymbol=Symbol();const proxyTargetSymbol=Symbol();const minValue=1e-11;const maxValue=1e12;const K=1e3;const maxFps=120;const emptyString="";const shortTransforms=new Map;shortTransforms.set("x","translateX");shortTransforms.set("y","translateY");shortTransforms.set("z","translateZ");const validTransforms=["translateX","translateY","translateZ","rotate","rotateX","rotateY","rotateZ","scale","scaleX","scaleY","scaleZ","skew","skewX","skewY","perspective","matrix","matrix3d"];const transformsFragmentStrings=validTransforms.reduce(((a,v)=>({...a,[v]:v+"("})),{});const noop=()=>{};const hexTestRgx=/(^#([\da-f]{3}){1,2}$)|(^#([\da-f]{4}){1,2}$)/i;const rgbExecRgx=/rgb\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*\)/i;const rgbaExecRgx=/rgba\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*(-?\d+|-?\d*.\d+)\s*\)/i;const hslExecRgx=/hsl\(\s*(-?\d+|-?\d*.\d+)\s*,\s*(-?\d+|-?\d*.\d+)%\s*,\s*(-?\d+|-?\d*.\d+)%\s*\)/i;const hslaExecRgx=/hsla\(\s*(-?\d+|-?\d*.\d+)\s*,\s*(-?\d+|-?\d*.\d+)%\s*,\s*(-?\d+|-?\d*.\d+)%\s*,\s*(-?\d+|-?\d*.\d+)\s*\)/i;const digitWithExponentRgx=/[-+]?\d*\.?\d+(?:[eE][-+]?\d+)?/g;const unitsExecRgx=/^([-+]?\d*\.?\d+(?:[eE][-+]?\d+)?)+([a-z]+|%)$/i;const lowerCaseRgx=/([a-z])([A-Z])/g;const transformsExecRgx=/(\w+)(\([^)]+\)+)/g;const relativeValuesExecRgx=/(\*=|\+=|-=)/;const defaults={id:null,keyframes:null,playbackEase:null,playbackRate:1,frameRate:maxFps,loop:0,reversed:false,alternate:false,autoplay:true,duration:K,delay:0,loopDelay:0,ease:"outQuad",composition:compositionTypes.replace,modifier:v=>v,onBegin:noop,onUpdate:noop,onRender:noop,onLoop:noop,onComplete:noop};const globals={defaults:defaults,root:doc,scope:null};const selectString=str=>{try{const nodes=globals.root.querySelectorAll(str);return nodes}catch(e){return}};const toLowerCase=str=>str.replace(lowerCaseRgx,"$1-$2").toLowerCase();const stringStartsWith=(str,sub)=>str.indexOf(sub)===0;const now=Date.now;const isArr=a=>Array.isArray(a);const isObj=a=>a&&a.constructor===Object;const isNum=a=>typeof a==="number"&&!isNaN(a);const isStr=a=>typeof a==="string";const isFnc=a=>typeof a==="function";const isUnd=a=>typeof a==="undefined";const isNil=a=>isUnd(a)||a===null;const isSvg=a=>isBrowser&&a instanceof SVGElement;const isHex=a=>hexTestRgx.test(a);const isRgb=a=>stringStartsWith(a,"rgb");const isHsl=a=>stringStartsWith(a,"hsl");const isCol=a=>isHex(a)||isRgb(a)||isHsl(a);const isKey=a=>!globals.defaults.hasOwnProperty(a);const parseNumber=str=>isStr(str)?parseFloat(str):str;const pow=Math.pow;const sqrt=Math.sqrt;const sin=Math.sin;const cos=Math.cos;const abs=Math.abs;const exp=Math.exp;const ceil=Math.ceil;const floor=Math.floor;const asin=Math.asin;const max=Math.max;const atan2=Math.atan2;const PI=Math.PI;const clamp=(v,min,max)=>v<min?min:v>max?max:v;const round=(v,decimalLength)=>{const m=10**(decimalLength||0);return Math.round(v*m)/m};const snap=(v,increment)=>increment?Math.round(v/increment)*increment:v;const interpolate=(start,end,progress)=>start+(end-start)*progress;const clampInfinity=v=>v===Infinity?maxValue:v===-Infinity?-maxValue:v;const clampZero=v=>v<minValue?minValue:v;const toArray=v=>{if(!isBrowser)return[v];if(isStr(v))v=selectString(v)||v;if(v instanceof NodeList||v instanceof HTMLCollection)return[].slice.call(v);return[v]};const cloneArray=a=>isArr(a)?[...a]:a;const mergeObjects=(o1,o2)=>{const merged={...o1};for(let p in o2)merged[p]=isUnd(o1[p])?o2[p]:o1[p];return merged};const forEachChildren=(parent,callback,reverse,prevProp="_prev",nextProp="_next")=>{let next=parent._head;let adjustedNextProp=nextProp;if(reverse){next=parent._tail;adjustedNextProp=prevProp}while(next){const currentNext=next[adjustedNextProp];callback(next);next=currentNext}};const removeChild=(parent,child,prevProp="_prev",nextProp="_next")=>{const prev=child[prevProp];const next=child[nextProp];prev?prev[nextProp]=next:parent._head=next;next?next[prevProp]=prev:parent._tail=prev;child[prevProp]=null;child[nextProp]=null};const addChild=(parent,child,sortMethod,prevProp="_prev",nextProp="_next")=>{let prev=parent._tail;while(prev&&sortMethod&&sortMethod(prev,child))prev=prev[prevProp];const next=prev?prev[nextProp]:parent._head;prev?prev[nextProp]=child:parent._head=child;next?next[prevProp]=child:parent._tail=child;child[prevProp]=prev;child[nextProp]=next};class Clock{constructor(){this.currentTime=0;this.deltaTime=0;this._elapsedTime=0;this._startTime=0;this._lastTime=0;this._scheduledTime=0;this._frameDuration=K/maxFps;this._fps=maxFps;this._speed=1;this._hasChildren=false}get frameRate(){return this._fps}set frameRate(frameRate){const previousFrameDuration=this._frameDuration;const fr=+frameRate;const fps=fr<minValue?minValue:fr;const frameDuration=K/fps;this._fps=fps;this._frameDuration=frameDuration;this._scheduledTime+=frameDuration-previousFrameDuration}get playbackRate(){return this._speed}set playbackRate(playbackRate){const pbr=+playbackRate;this._speed=pbr<minValue?minValue:pbr}requestTick(time){const scheduledTime=this._scheduledTime;const elapsedTime=this._elapsedTime;this._elapsedTime+=time-elapsedTime;if(elapsedTime<scheduledTime)return tickModes.NONE;const frameDuration=this._frameDuration;const frameDelta=elapsedTime-scheduledTime;this._scheduledTime+=frameDelta<frameDuration?frameDuration:frameDelta;return tickModes.AUTO}computeDeltaTime(time){const delta=time-this._lastTime;this.deltaTime=delta;this._lastTime=time;return delta}}const render=(tickable,time,muteCallbacks,internalRender,tickMode)=>{const duration=tickable.duration;const currentTime=tickable.currentTime;const _currentIteration=tickable._currentIteration;const _iterationDuration=tickable._iterationDuration;const _iterationCount=tickable._iterationCount;const _loopDelay=tickable._loopDelay;const _reversed=tickable.reversed;const _alternate=tickable._alternate;const _hasChildren=tickable._hasChildren;const updateStartTime=tickable._delay;const updateEndTime=updateStartTime+_iterationDuration;const tickableTime=clamp(time-updateStartTime,-updateStartTime,duration);const deltaTime=tickableTime-currentTime;const isOverTime=tickableTime>=duration;const forceTick=tickMode===tickModes.FORCE;const autoTick=tickMode===tickModes.AUTO;const isManual=forceTick||(deltaTime<0?deltaTime*-1:deltaTime)>=200;let hasBegun=tickable.began;let isOdd=0;let iterationElapsedTime=tickableTime;if(_iterationCount>1){const currentIteration=~~(tickableTime/(_iterationDuration+(isOverTime?0:_loopDelay)));tickable._currentIteration=clamp(currentIteration,0,_iterationCount);if(isOverTime){tickable._currentIteration--}isOdd=tickable._currentIteration%2;iterationElapsedTime=tickableTime%(_iterationDuration+_loopDelay)}const isReversed=_reversed^(_alternate&&isOdd);const _ease=tickable._ease;let iterationTime=isOverTime?isReversed?0:duration:isReversed?_iterationDuration-iterationElapsedTime:iterationElapsedTime;if(_ease){iterationTime=_iterationDuration*_ease(iterationTime/_iterationDuration)||0}const isRunningBackwards=iterationTime<tickable._iterationTime;const seekMode=isManual?isRunningBackwards?2:1:0;tickable._iterationTime=iterationTime;tickable._backwards=isRunningBackwards&&!isReversed;if(!muteCallbacks&&!hasBegun&&tickableTime>0){hasBegun=tickable.began=true;tickable.onBegin(tickable)}tickable.currentTime=tickableTime;let hasRendered=0;if(hasBegun&&tickable._currentIteration!==_currentIteration){if(!muteCallbacks)tickable.onLoop(tickable);if(_hasChildren){forEachChildren(tickable,(child=>child.reset()),true)}}if(forceTick||autoTick&&(time>=updateStartTime&&time<=updateEndTime||time<=updateStartTime&&currentTime>0||time>=updateEndTime&&currentTime!==duration)||iterationTime>=updateEndTime&&currentTime!==duration||iterationTime<=updateStartTime&&currentTime>0||time<=currentTime&&currentTime===duration&&tickable.completed){if(hasBegun){tickable.computeDeltaTime(currentTime);if(!muteCallbacks)tickable.onUpdate(tickable)}if(!_hasChildren){let tween=tickable._head;let tweenTarget;let tweenStyle;let tweenTargetTransforms;let tweenTargetTransformsProperties;let tweenTransformsNeedUpdate=0;const absoluteTime=tickable._offset+updateStartTime+iterationTime;while(tween){const tweenComposition=tween._composition;const tweenCurrentTime=tween._currentTime;const tweenChangeDuration=tween._changeDuration;const tweenAbsEndTime=tween._absoluteStartTime+tween._changeDuration;const tweenNextRep=tween._nextRep;const tweenPrevRep=tween._prevRep;const tweenHasComposition=tweenComposition!==compositionTypes.none;if((seekMode||(tweenCurrentTime!==tweenChangeDuration||absoluteTime<=tweenAbsEndTime+(tweenNextRep?tweenNextRep._delay:0))&&(tweenCurrentTime!==0||absoluteTime>=tween._absoluteStartTime))&&(!tweenHasComposition||!tween._isOverridden&&(!tween._isOverlapped||absoluteTime<=tweenAbsEndTime)&&(!tweenNextRep||(tweenNextRep._isOverridden||absoluteTime<=tweenNextRep._absoluteStartTime))&&(!tweenPrevRep||(tweenPrevRep._isOverridden||absoluteTime>=tweenPrevRep._absoluteStartTime+tweenPrevRep._changeDuration+tween._delay)))){const tweenNewTime=tween._currentTime=clamp(iterationTime-tween._startTime,0,tweenChangeDuration);const tweenProgress=tween._ease(tweenNewTime/tween._updateDuration);const tweenModifier=tween._modifier;const tweenValueType=tween._valueType;let value;let number;if(tweenValueType===valueTypes.NUMBER){value=number=tweenModifier(interpolate(tween._fromNumber,tween._toNumber,tweenProgress))}else if(tweenValueType===valueTypes.UNIT){number=tweenModifier(round(interpolate(tween._fromNumber,tween._toNumber,tweenProgress),3));value=`${number}${tween._unit}`}else if(tweenValueType===valueTypes.COLOR){const fn=tween._fromNumbers;const tn=tween._toNumbers;const r=round(clamp(tweenModifier(interpolate(fn[0],tn[0],tweenProgress)),0,255),0);const g=round(clamp(tweenModifier(interpolate(fn[1],tn[1],tweenProgress)),0,255),0);const b=round(clamp(tweenModifier(interpolate(fn[2],tn[2],tweenProgress)),0,255),0);const a=clamp(tweenModifier(interpolate(fn[3],tn[3],tweenProgress)),0,1);value=`rgba(${r},${g},${b},${a})`;if(tweenHasComposition){const ns=tween._numbers;ns[0]=r;ns[1]=g;ns[2]=b;ns[3]=a}}else if(tweenValueType===valueTypes.COMPLEX){value=tween._strings[0];for(let j=0,l=tween._toNumbers.length;j<l;j++){const n=tweenModifier(round(interpolate(tween._fromNumbers[j],tween._toNumbers[j],tweenProgress),5));const s=tween._strings[j+1];value+=`${s?n+s:n}`;if(tweenHasComposition){tween._numbers[j]=n}}}if(tweenHasComposition){tween._number=number}if(!internalRender&&tweenComposition!==compositionTypes.blend){const tweenProperty=tween.property;const tweenType=tween._tweenType;tweenTarget=tween.target;if(tweenType===tweenTypes.OBJECT){tweenTarget[tweenProperty]=value}else if(tweenType===tweenTypes.ATTRIBUTE){tweenTarget.setAttribute(tweenProperty,value)}else{tweenStyle=tweenTarget.style;if(tweenType===tweenTypes.TRANSFORM){if(tweenTarget!==tweenTargetTransforms){tweenTargetTransforms=tweenTarget;tweenTargetTransformsProperties=tweenTarget[transformsSymbol]}tweenTargetTransformsProperties[tweenProperty]=value;tweenTransformsNeedUpdate=1}else if(tweenType===tweenTypes.CSS){tweenStyle[tweenProperty]=value}else if(tweenType===tweenTypes.CSS_VAR){tweenStyle.setProperty(tweenProperty,value)}}if(hasBegun)hasRendered=1}else{tween._value=value}}if(tweenTransformsNeedUpdate&&tween._renderTransforms){let str=emptyString;for(let key in tweenTargetTransformsProperties){str+=`${transformsFragmentStrings[key]}${tweenTargetTransformsProperties[key]}) `}tweenStyle.transform=str;tweenTransformsNeedUpdate=0}tween=tween._next}if(hasRendered&&!muteCallbacks){tickable.onRender(tickable)}}}if(hasBegun&&isOverTime){if(_iterationCount===Infinity){tickable._startTime+=tickable.duration}else if(tickable._currentIteration>=_iterationCount-1){tickable.paused=true;if(!tickable.completed){tickable.completed=true;if(!muteCallbacks){tickable.onComplete(tickable);tickable._resolve(tickable)}}}}return hasRendered};const tick=(tickable,time,muteCallbacks,internalRender,tickMode)=>{render(tickable,time,muteCallbacks,internalRender,tickMode);if(tickable._hasChildren){let hasRendered=0;const childrenTime=internalRender?time:tickable._iterationTime;const childrenTickTime=now();forEachChildren(tickable,(child=>{hasRendered+=render(child,(childrenTime-child._offset)*child._speed,muteCallbacks,internalRender,child._fps<tickable._fps?child.requestTick(childrenTickTime):tickMode)}),tickable._backwards);if(tickable.began&&hasRendered){tickable.onRender(tickable)}}};const additive={animation:null,update:noop};const addAdditiveAnimation=lookups=>{let animation=additive.animation;if(!animation){animation={duration:minValue,_offset:0,_delay:0,_head:null,_tail:null};additive.animation=animation;additive.update=()=>{lookups.forEach((propertyAnimation=>{for(let propertyName in propertyAnimation){const tweens=propertyAnimation[propertyName];const lookupTween=tweens._head;const additiveValues=lookupTween._valueType===valueTypes.COMPLEX?cloneArray(lookupTween._fromNumbers):null;let additiveValue=lookupTween._fromNumber;let tween=tweens._tail;while(tween&&tween!==lookupTween){if(additiveValues){tween._numbers.forEach(((value,i)=>additiveValues[i]+=value))}else{additiveValue+=tween._number}tween=tween._prevAdd}lookupTween._toNumber=additiveValue;lookupTween._toNumbers=additiveValues}}));tick(animation,1,1,0,tickModes.FORCE)}}return animation};const engineTickMethod=isBrowser?requestAnimationFrame:setImmediate;const engineCancelMethod=isBrowser?cancelAnimationFrame:clearImmediate;class Engine extends Clock{constructor(){super();const initTime=now();this.currentTime=initTime;this._elapsedTime=initTime;this._startTime=initTime;this._lastTime=initTime;this.useDefaultMainLoop=true;this.suspendWhenHidden=true;this._reqId=0;this._head=null;this._tail=null}update(){const time=this.currentTime=now();if(this.requestTick(time)){this.computeDeltaTime(time);const engineSpeed=this._speed;const engineFps=this._fps;let activeTickable=this._head;while(activeTickable){const nextTickable=activeTickable._next;if(!activeTickable.paused){tick(activeTickable,(time-activeTickable._startTime)*activeTickable._speed*engineSpeed,0,0,activeTickable._fps<engineFps?activeTickable.requestTick(time):tickModes.AUTO)}else{removeChild(engine,activeTickable);this._hasChildren=!!this._tail;activeTickable._running=false;if(activeTickable.completed&&!activeTickable._cancelled){activeTickable.cancel()}}activeTickable=nextTickable}additive.update()}}start(){return this.useDefaultMainLoop&&!this._reqId?this._reqId=engineTickMethod(mainLoop):0}resume(){forEachChildren(this,(child=>child.resetTime()));return this.start()}suspend(){this._reqId=engineCancelMethod(this._reqId);return this}get playbackRate(){return super.playbackRate}set playbackRate(playbackRate){super.playbackRate=playbackRate;forEachChildren(this,(child=>child.playbackRate=child._speed))}}const engine=new Engine;const mainLoop=()=>{if(engine._head){engine._reqId=engineTickMethod(mainLoop);engine.update()}else{engine._reqId=0}};const parseTargets=targets=>{if(isNil(targets))return;if(isArr(targets)){const targetsArray=targets;const parsed=[].concat(...targetsArray.map(toArray));return parsed.filter(((t,index)=>parsed.indexOf(t)===index))}else{return toArray(targets)}};const registerTargets=targets=>{if(isNil(targets))return;const parsedTargetsArray=parseTargets(targets);for(let i=0,l=parsedTargetsArray.length;i<l;i++){const target=parsedTargetsArray[i];if(!target[isRegisteredTargetSymbol]){target[isRegisteredTargetSymbol]=true;const isSvgType=isSvg(target);const isDom=target.nodeType||isSvgType;if(isDom){target[isDomSymbol]=true;target[isSvgSymbol]=isSvgType;target[transformsSymbol]={}}}}return parsedTargetsArray};const none=t=>t;const calcBezier=(aT,aA1,aA2)=>(((1-3*aA2+3*aA1)*aT+(3*aA2-6*aA1))*aT+3*aA1)*aT;const binarySubdivide=(aX,mX1,mX2)=>{let aA=0,aB=1,currentX,currentT,i=0;do{currentT=aA+(aB-aA)/2;currentX=calcBezier(currentT,mX1,mX2)-aX;if(currentX>0){aB=currentT}else{aA=currentT}}while(abs(currentX)>1e-7&&++i<100);return currentT};const cubicBezier=(mX1,mY1,mX2,mY2)=>mX1===mY1&&mX2===mY2?none:t=>t===0||t===1?t:calcBezier(binarySubdivide(t,mX1,mX2),mY1,mY2);const steps=(steps=10,fromStart)=>{const roundMethod=fromStart?ceil:floor;return t=>roundMethod(clamp(t,0,1)*steps)*(1/steps)};const halfPI=PI/2;const doublePI=PI*2;const easeInPower=(p=1.64)=>t=>pow(t,+p);const easeInFunctions={[emptyString]:easeInPower,Quad:easeInPower(2),Cubic:easeInPower(3),Quart:easeInPower(4),Quint:easeInPower(5),Sine:t=>1-cos(t*halfPI),Circ:t=>1-sqrt(1-t*t),Expo:t=>t?pow(2,10*t-10):0,Bounce:t=>{let pow2,b=4;while(t<((pow2=pow(2,--b))-1)/11);return 1/pow(4,3-b)-7.5625*pow((pow2*3-2)/22-t,2)},Back:(overshoot=1.70158)=>t=>(+overshoot+1)*t*t*t-+overshoot*t*t,Elastic:(amplitude=1,period=.3)=>{const a=clamp(+amplitude,1,10);const p=clamp(+period,minValue,2);const s=p/doublePI*asin(1/a);const e=doublePI/p;return t=>t===0||t===1?t:-a*pow(2,-10*(1-t))*sin((1-t-s)*e)}};const easeTypes={in:easeIn=>t=>easeIn(t),out:easeIn=>t=>1-easeIn(1-t),inOut:easeIn=>t=>t<.5?easeIn(t*2)/2:1-easeIn(t*-2+2)/2,outIn:easeIn=>t=>t<.5?(1-easeIn(1-t*2))/2:(easeIn(t*2-1)+1)/2};const linear=(...args)=>{const argsLength=args.length;if(!argsLength)return none;const totalPoints=argsLength-1;const firstArg=args[0];const lastArg=args[totalPoints];const xPoints=[0];const yPoints=[parseNumber(firstArg)];for(let i=1;i<totalPoints;i++){const arg=args[i];const splitValue=isStr(arg)?arg.trim().split(" "):[arg];const value=splitValue[0];const percent=splitValue[1];xPoints.push(!isUnd(percent)?parseNumber(percent)/100:i/totalPoints);yPoints.push(parseNumber(value))}yPoints.push(parseNumber(lastArg));xPoints.push(1);return function easeLinear(t){for(let i=1,l=xPoints.length;i<l;i++){const currentX=xPoints[i];if(t<=currentX){const prevX=xPoints[i-1];const prevY=yPoints[i-1];return prevY+(yPoints[i]-prevY)*(t-prevX)/(currentX-prevX)}}return yPoints[yPoints.length-1]}};const irregular=(length=10,randomness=1)=>{const values=[0];const total=length-1;for(let i=1;i<total;i++){const previousValue=values[i-1];const spacing=i/total;const segmentEnd=(i+1)/total;const randomVariation=spacing+(segmentEnd-spacing)*Math.random();const randomValue=spacing*(1-randomness)+randomVariation*randomness;values.push(clamp(randomValue,previousValue,1))}values.push(1);return linear(...values)};const eases={linear:linear,irregular:irregular,steps:steps,cubicBezier:cubicBezier};const easesLookups={linear:none};for(let type in easeTypes){for(let name in easeInFunctions){const easeIn=easeInFunctions[name];const easeType=easeTypes[type];const hasParams=name===emptyString||name==="Back"||name==="Elastic";const easeFactory=hasParams?(a,b)=>easeType(easeIn(a,b)):easeType(easeIn);const easeName=type+name;eases[easeName]=easeFactory;easesLookups[easeName]=hasParams?easeFactory():easeFactory}}const parseEaseString=string=>{if(string.indexOf("(")<=-1)return none;const split=string.slice(0,-1).split("(");const parsedFn=eases[split[0]];const result=parsedFn?easesLookups[string]=parsedFn(...split[1].split(",")):none;return result};const parseEasings=ease=>isFnc(ease)?ease:isStr(ease)?easesLookups[ease]?easesLookups[ease]:parseEaseString(ease):none;const parseInlineTransforms=(target,propName,animationInlineStyles)=>{const inlineTransforms=target.style.transform;let inlinedStylesPropertyValue;if(inlineTransforms){const cachedTransforms=target[transformsSymbol];let t;while(t=transformsExecRgx.exec(inlineTransforms)){const inlinePropertyName=t[1];const inlinePropertyValue=t[2].slice(1,-1);cachedTransforms[inlinePropertyName]=inlinePropertyValue;if(inlinePropertyName===propName){inlinedStylesPropertyValue=inlinePropertyValue;if(animationInlineStyles){animationInlineStyles[propName]=inlinePropertyValue}}}}return inlineTransforms&&!isUnd(inlinedStylesPropertyValue)?inlinedStylesPropertyValue:stringStartsWith(propName,"scale")?"1":stringStartsWith(propName,"rotate")||stringStartsWith(propName,"skew")?"0deg":"0px"};const getPath=path=>{const parsedTargets=parseTargets(path);const $parsedSvg=parsedTargets[0];if(!$parsedSvg||!isSvg($parsedSvg))return;return $parsedSvg};const morphTo=(path2,precision=.33)=>$path1=>{const $path2=getPath(path2);if(!$path2)return;const isPath=$path1.tagName==="path";const separator=isPath?" ":",";const previousPoints=$path1[morphPointsSymbol];if(previousPoints)$path1.setAttribute(isPath?"d":"points",previousPoints);let v1="",v2="";if(!precision){v1=$path1.getAttribute(isPath?"d":"points");v2=$path2.getAttribute(isPath?"d":"points")}else{const length1=$path1.getTotalLength();const length2=$path2.getTotalLength();const maxPoints=Math.max(Math.ceil(length1*precision),Math.ceil(length2*precision));for(let i=0;i<maxPoints;i++){const t=i/(maxPoints-1);const pointOnPath1=$path1.getPointAtLength(length1*t);const pointOnPath2=$path2.getPointAtLength(length2*t);const prefix=isPath?i===0?"M":"L":"";v1+=prefix+round(pointOnPath1.x,3)+separator+pointOnPath1.y+" ";v2+=prefix+round(pointOnPath2.x,3)+separator+pointOnPath2.y+" "}}$path1[morphPointsSymbol]=v2;return[v1,v2]};function createDrawableProxy($el,start,end){const elStyles=getComputedStyle($el);const strokeWidth=parseFloat(elStyles.strokeWidth);const strokeLineCap=elStyles.strokeLinecap;const extraStroke=strokeLineCap==="butt"?0:strokeWidth;const totalPathLength=$el.getTotalLength();const p=0;const P=1e5;const bleed=round(P/totalPathLength,p);const butt=extraStroke*bleed;const pathLength=P-butt;const proxy=new Proxy($el,{get(target,property){const value=target[property];if(property===proxyTargetSymbol)return target;if(property==="setAttribute"){return(...args)=>{if(args[0]==="draw"){const value=args[1];const values=value.split(" ");const v1=+values[0];const v2=+values[1];const bl=v1!==0&&v1===v2||(v1===1||v2===1)?0:bleed;const os=round(v1*-P,p);const d1=round(v2*P+os,p);const d2=round(P-d1,p);target.setAttribute("stroke-dashoffset",`${os+bl}`);target.setAttribute("stroke-dasharray",`${d1+bl} ${d2+bl+1+butt}`)}return Reflect.apply(value,target,args)}}return isFnc(value)?(...args)=>Reflect.apply(value,target,args):value}});if($el.getAttribute("pathLength")!==`${pathLength}`){$el.setAttribute("pathLength",`${pathLength}`);proxy.setAttribute("draw",`${start} ${end}`)}return proxy}const createDrawable=(selector,start=0,end=0)=>{const els=parseTargets(selector);els.forEach((($el,i)=>els[i]=createDrawableProxy($el,start,end)));return els};const getPathPoint=($path,progress,lookup=0)=>$path.getPointAtLength(progress+lookup>=1?progress+lookup:0);const getPathProgess=($path,pathProperty)=>$el=>{const totalLength=+$path.getTotalLength();const inSvg=$el[isSvgSymbol];const ctm=$path.getCTM();return{from:0,to:totalLength,modifier:progress=>{if(pathProperty==="a"){const p0=getPathPoint($path,progress,-1);const p1=getPathPoint($path,progress,+1);return atan2(p1.y-p0.y,p1.x-p0.x)*180/PI}else{const p=getPathPoint($path,progress,0);return pathProperty==="x"?inSvg?p.x:p.x*ctm.a+p.y*ctm.c+ctm.e:inSvg?p.y:p.x*ctm.b+p.y*ctm.d+ctm.f}}}};const createMotionPath=path=>{const $path=getPath(path);if(!$path)return;return{x:getPathProgess($path,"x"),y:getPathProgess($path,"y"),angle:getPathProgess($path,"a")}};const cssReservedProperties=["opacity","rotate","overflow","color"];const isValidSVGAttribute=(el,propertyName)=>{if(cssReservedProperties.includes(propertyName))return false;if(propertyName in el.style||propertyName in el){if(propertyName==="scale"){const elParentNode=el.parentNode;return elParentNode&&elParentNode.tagName==="filter"}return true}};const svg={morphTo:morphTo,createMotionPath:createMotionPath,createDrawable:createDrawable};const rgbToRgba=rgbValue=>{const rgba=rgbExecRgx.exec(rgbValue)||rgbaExecRgx.exec(rgbValue);const a=!isUnd(rgba[4])?+rgba[4]:1;return[+rgba[1],+rgba[2],+rgba[3],a]};const hexToRgba=hexValue=>{const hexLength=hexValue.length;const isShort=hexLength===4||hexLength===5;return[+("0x"+hexValue[1]+hexValue[isShort?1:2]),+("0x"+hexValue[isShort?2:3]+hexValue[isShort?2:4]),+("0x"+hexValue[isShort?3:5]+hexValue[isShort?3:6]),hexLength===5||hexLength===9?+(+("0x"+hexValue[isShort?4:7]+hexValue[isShort?4:8])/255).toFixed(3):1]};const hue2rgb=(p,q,t)=>{if(t<0)t+=1;if(t>1)t-=1;return t<1/6?p+(q-p)*6*t:t<1/2?q:t<2/3?p+(q-p)*(2/3-t)*6:p};const hslToRgba=hslValue=>{const hsla=hslExecRgx.exec(hslValue)||hslaExecRgx.exec(hslValue);const h=+hsla[1]/360;const s=+hsla[2]/100;const l=+hsla[3]/100;const a=!isUnd(hsla[4])?+hsla[4]:1;let r,g,b;if(s===0){r=g=b=l}else{const q=l<.5?l*(1+s):l+s-l*s;const p=2*l-q;r=round(hue2rgb(p,q,h+1/3)*255,0);g=round(hue2rgb(p,q,h)*255,0);b=round(hue2rgb(p,q,h-1/3)*255,0)}return[r,g,b,a]};const convertColorStringValuesToRgbaArray=colorString=>isRgb(colorString)?rgbToRgba(colorString):isHex(colorString)?hexToRgba(colorString):isHsl(colorString)?hslToRgba(colorString):[0,0,0,1];const setValue=(targetValue,defaultValue)=>isUnd(targetValue)?defaultValue:targetValue;const getFunctionValue=(value,target,index,total,store)=>{if(isFnc(value)){const func=()=>{const computed=value(target,index,total);return!isNaN(+computed)?+computed:computed||0};if(store){store.func=func}return func()}else{return value}};const getTweenType=(target,prop)=>{const type=!target[isDomSymbol]?tweenTypes.OBJECT:target[isSvgSymbol]&&isValidSVGAttribute(target,prop)?tweenTypes.ATTRIBUTE:validTransforms.includes(prop)||shortTransforms.get(prop)?tweenTypes.TRANSFORM:stringStartsWith(prop,"--")?tweenTypes.CSS_VAR:prop in target.style?tweenTypes.CSS:!isNil(target.getAttribute(prop))?tweenTypes.ATTRIBUTE:!isUnd(target[prop])?tweenTypes.OBJECT:tweenTypes.INVALID;if(type===tweenTypes.INVALID)console.warn(`Can't find property '${prop}' on target '${target}'.`);return type};const getCSSValue=(target,propName,animationInlineStyles)=>{const inlineStyles=target.style[propName];if(inlineStyles&&animationInlineStyles){animationInlineStyles[propName]=inlineStyles}const value=inlineStyles||getComputedStyle(target[proxyTargetSymbol]||target).getPropertyValue(propName);return value==="auto"?"0":value};const getOriginalAnimatableValue=(target,propName,tweenType,animationInlineStyles)=>{const type=!isUnd(tweenType)?tweenType:getTweenType(target,propName);return type===tweenTypes.OBJECT?target[propName]||0:type===tweenTypes.ATTRIBUTE?target.getAttribute(propName):type===tweenTypes.TRANSFORM?parseInlineTransforms(target,propName,animationInlineStyles):type===tweenTypes.CSS_VAR?getCSSValue(target,propName,animationInlineStyles).trimStart():getCSSValue(target,propName,animationInlineStyles)};const getRelativeValue=(x,y,operator)=>operator==="-"?x-y:operator==="+"?x+y:x*y;const createDecomposedValueTargetObject=()=>({t:valueTypes.NUMBER,n:0,u:null,o:null,d:null,s:null});const decomposeRawValue=(rawValue,targetObject)=>{targetObject.t=valueTypes.NUMBER;targetObject.n=0;targetObject.u=null;targetObject.o=null;targetObject.d=null;targetObject.s=null;if(!rawValue)return targetObject;let val=rawValue;const numberedVal=+val;if(!isNaN(numberedVal)){targetObject.n=numberedVal;return targetObject}else{const matchedRelativeOperator=relativeValuesExecRgx.exec(val);if(matchedRelativeOperator){val=val.slice(2);targetObject.o=matchedRelativeOperator[0][0]}const unitMatch=val.includes(" ")?false:unitsExecRgx.exec(val);if(unitMatch){targetObject.t=valueTypes.UNIT;targetObject.n=+unitMatch[1];targetObject.u=unitMatch[2];return targetObject}else if(targetObject.o){targetObject.n=+val;return targetObject}else if(isCol(val)){targetObject.t=valueTypes.COLOR;targetObject.d=convertColorStringValuesToRgbaArray(val);return targetObject}else{const stringifiedVal=val+emptyString;const matchedNumbers=stringifiedVal.match(digitWithExponentRgx);targetObject.t=valueTypes.COMPLEX;targetObject.d=matchedNumbers?matchedNumbers.map(Number):[];targetObject.s=stringifiedVal.split(digitWithExponentRgx)||[];return targetObject}}};const decomposeTweenValue=(tween,targetObject)=>{targetObject.t=tween._valueType;targetObject.n=tween._toNumber;targetObject.u=tween._unit;targetObject.o=null;targetObject.d=cloneArray(tween._toNumbers);targetObject.s=cloneArray(tween._strings);return targetObject};const decomposedOriginalValue=createDecomposedValueTargetObject();const propertyNamesCache={};const sanitizePropertyName=(propertyName,target,tweenType)=>{if(tweenType===tweenTypes.TRANSFORM){const t=shortTransforms.get(propertyName);return t?t:propertyName}else if(tweenType===tweenTypes.CSS||tweenType===tweenTypes.ATTRIBUTE&&(isSvg(target)&&propertyName in target.style)){const cachedPropertyName=propertyNamesCache[propertyName];if(cachedPropertyName){return cachedPropertyName}else{const lowerCaseName=toLowerCase(propertyName);propertyNamesCache[propertyName]=lowerCaseName;return lowerCaseName}}else{return propertyName}};const angleUnitsMap={deg:1,rad:180/PI,turn:360};const convertedValuesCache={};const convertValueUnit=(el,decomposedValue,unit,force=false)=>{const currentUnit=decomposedValue.u;const currentNumber=decomposedValue.n;if(decomposedValue.t===valueTypes.UNIT&&currentUnit===unit){return decomposedValue}const cachedKey=currentNumber+currentUnit+unit;const cached=convertedValuesCache[cachedKey];if(!isUnd(cached)&&!force){decomposedValue.n=cached}else{let convertedValue;if(currentUnit in angleUnitsMap){convertedValue=currentNumber*angleUnitsMap[currentUnit]/angleUnitsMap[unit]}else{const baseline=100;const tempEl=el.cloneNode();const parentNode=el.parentNode;const parentEl=parentNode&&parentNode!==doc?parentNode:doc.body;parentEl.appendChild(tempEl);const elStyle=tempEl.style;elStyle.width=baseline+currentUnit;const currentUnitWidth=tempEl.offsetWidth||baseline;elStyle.width=baseline+unit;const newUnitWidth=tempEl.offsetWidth||baseline;const factor=currentUnitWidth/newUnitWidth;parentEl.removeChild(tempEl);convertedValue=factor*currentNumber}decomposedValue.n=convertedValue;convertedValuesCache[cachedKey]=convertedValue}decomposedValue.t===valueTypes.UNIT;decomposedValue.u=unit;return decomposedValue};const lookups={_rep:new WeakMap,_add:new Map};const getTweenSiblings=(target,property,lookup="_rep")=>{const lookupMap=lookups[lookup];let targetLookup=lookupMap.get(target);if(!targetLookup){targetLookup={};lookupMap.set(target,targetLookup)}return targetLookup[property]?targetLookup[property]:targetLookup[property]={_head:null,_tail:null}};const addTweenSortMethod=(p,c)=>p._isOverridden||p._absoluteStartTime>c._absoluteStartTime;const overrideTween=tween=>{tween._isOverlapped=1;tween._isOverridden=1;tween._changeDuration=minValue;tween._currentTime=minValue};const composeTween=(tween,siblings)=>{const tweenCompositionType=tween._composition;if(tweenCompositionType===compositionTypes.replace){const tweenAbsStartTime=tween._absoluteStartTime;addChild(siblings,tween,addTweenSortMethod,"_prevRep","_nextRep");const prevSibling=tween._prevRep;if(prevSibling){const prevParent=prevSibling.parent;const prevAbsEndTime=prevSibling._absoluteStartTime+prevSibling._changeDuration;if(tween.parent.id!==prevParent.id&&prevParent._iterationCount>1&&prevAbsEndTime+(prevParent.duration-prevParent._iterationDuration)>tweenAbsStartTime){overrideTween(prevSibling);let prevPrevSibling=prevSibling._prevRep;while(prevPrevSibling&&prevPrevSibling.parent.id===prevParent.id){overrideTween(prevPrevSibling);prevPrevSibling=prevPrevSibling._prevRep}}const absoluteUpdateStartTime=tweenAbsStartTime-tween._delay;if(prevAbsEndTime>absoluteUpdateStartTime){const prevChangeStartTime=prevSibling._startTime;const prevTLOffset=prevAbsEndTime-(prevChangeStartTime+prevSibling._updateDuration);prevSibling._changeDuration=absoluteUpdateStartTime-prevTLOffset-prevChangeStartTime;prevSibling._currentTime=prevSibling._changeDuration;prevSibling._isOverlapped=1;if(prevSibling._changeDuration<minValue){overrideTween(prevSibling)}}let parentActiveAnimation=0;forEachChildren(prevParent,(t=>{parentActiveAnimation-=t._isOverridden-1}));if(parentActiveAnimation===0){prevParent.completed=true;prevParent.pause()}}}else if(tweenCompositionType===compositionTypes.blend){const additiveTweenSiblings=getTweenSiblings(tween.target,tween.property,"_add");const additiveAnimation=addAdditiveAnimation(lookups._add);let lookupTween=additiveTweenSiblings._head;if(!lookupTween){lookupTween={...tween};lookupTween._composition=compositionTypes.replace;lookupTween._updateDuration=minValue;lookupTween._startTime=0;lookupTween._numbers=cloneArray(tween._fromNumbers);lookupTween._number=0;lookupTween._next=null;lookupTween._prev=null;addChild(additiveTweenSiblings,lookupTween);addChild(additiveAnimation,lookupTween)}const toNumber=tween._toNumber;tween._fromNumber=lookupTween._fromNumber-toNumber;tween._toNumber=0;tween._numbers=cloneArray(tween._fromNumbers);tween._number=0;lookupTween._fromNumber=toNumber;if(tween._toNumbers){const toNumbers=cloneArray(tween._toNumbers);if(toNumbers){toNumbers.forEach(((value,i)=>{tween._fromNumbers[i]=lookupTween._fromNumbers[i]-value;tween._toNumbers[i]=0}))}lookupTween._fromNumbers=toNumbers}addChild(additiveTweenSiblings,tween,null,"_prevAdd","_nextAdd")}return tween};const removeTweenSliblings=tween=>{const tweenComposition=tween._composition;if(tweenComposition!==compositionTypes.none){const tweenTarget=tween.target;const tweenProperty=tween.property;const tweenSiblings=getTweenSiblings(tweenTarget,tweenProperty);removeChild(tweenSiblings,tween,"_prevRep","_nextRep");if(tweenComposition===compositionTypes.blend){const additiveTweenSliblings=getTweenSiblings(tweenTarget,tweenProperty,"_add");removeChild(additiveTweenSliblings,tween,"_prevAdd","_nextAdd")}}return tween};const resetTimerProperties=timer=>{timer.paused=true;timer.began=false;timer.completed=false;return timer};const reviveTimer=timer=>{if(!timer._cancelled)return timer;if(timer._hasChildren){forEachChildren(timer,reviveTimer)}else{forEachChildren(timer,(tween=>{if(tween._composition!==compositionTypes.none){composeTween(tween,getTweenSiblings(tween.target,tween.property))}}))}timer._cancelled=0;return timer};let timerId=0;class Timer extends Clock{constructor(parameters={},parent=null,parentPosition=0){super();const{id:id,delay:delay,duration:duration,reversed:reversed,alternate:alternate,loop:loop,loopDelay:loopDelay,autoplay:autoplay,frameRate:frameRate,playbackRate:playbackRate,onComplete:onComplete,onLoop:onLoop,onBegin:onBegin,onUpdate:onUpdate}=parameters;if(globals.scope)globals.scope.revertibles.push(this);const timerInitTime=parent?0:engine._elapsedTime;const timerDefaults=parent?parent.defaults:globals.defaults;const timerDelay=isFnc(delay)||isUnd(delay)?timerDefaults.delay:+delay;const timerDuration=isFnc(duration)||isUnd(duration)?Infinity:+duration;const timerLoop=setValue(loop,timerDefaults.loop);const timerLoopDelay=setValue(loopDelay,timerDefaults.loopDelay);const timerIterationCount=timerLoop===true||timerLoop===Infinity||timerLoop<0?Infinity:timerLoop+1;this.id=!isUnd(id)?id:duration===minValue?0:++timerId;this.parent=parent;this.duration=clampInfinity((timerDuration+timerLoopDelay)*timerIterationCount-timerLoopDelay);this.paused=true;this.began=false;this.completed=false;this.reversed=+setValue(reversed,timerDefaults.reversed);this.onBegin=onBegin||timerDefaults.onBegin;this.onUpdate=onUpdate||timerDefaults.onUpdate;this.onLoop=onLoop||timerDefaults.onLoop;this.onComplete=onComplete||timerDefaults.onComplete;this._autoplay=parent?false:setValue(autoplay,timerDefaults.autoplay);this._offset=parent?parentPosition:engine._elapsedTime-engine._startTime;this._delay=timerDelay;this._loopDelay=timerLoopDelay;this._iterationTime=0;this._iterationDuration=timerDuration;this._iterationCount=timerIterationCount;this._currentIteration=0;this._resolve=noop;this._hasChildren=false;this._running=false;this._cancelled=0;this._reversed=this.reversed;this._alternate=setValue(alternate,timerDefaults.alternate);this._backwards=false;this._prev=null;this._next=null;this._elapsedTime=timerInitTime;this._startTime=timerInitTime;this._lastTime=timerInitTime;this._fps=setValue(frameRate,timerDefaults.frameRate);this._speed=setValue(playbackRate,timerDefaults.playbackRate)}get progress(){return round(this.currentTime/this.duration,6)}set progress(progress){const paused=this.paused;this.pause().seek(this.duration*+progress);if(!paused)this.play()}get playbackRate(){return super.playbackRate}set playbackRate(playbackRate){super.playbackRate=playbackRate;this.resetTime()}reset(internalRender=0){reviveTimer(this);if(!this._reversed!==!this.reversed){this.reverse()}this._iterationTime=this._iterationDuration;tick(this,0,1,internalRender,tickModes.FORCE);resetTimerProperties(this);if(this._hasChildren){forEachChildren(this,resetTimerProperties)}return this}init(internalRender=0){this.frameRate=this._fps;this.playbackRate=this._speed;if(!internalRender&&this._hasChildren){tick(this,this.duration,1,internalRender,tickModes.FORCE)}this.reset(internalRender);const autoplay=this._autoplay;if(autoplay===true){this.play()}else if(!internalRender&&autoplay&&!isUnd(autoplay.linked)){autoplay.link(this)}return this}resetTime(){const timeScale=1/(this._speed*engine._speed);this._startTime=now()-(this.currentTime+this._delay)*timeScale-12;return this}pause(){if(this.paused)return this;this.paused=true;return this}play(){if(!this.paused)return this;this.paused=false;if(this.duration<=minValue){tick(this,1,0,0,tickModes.FORCE)}else{if(!this._running){addChild(engine,this);engine._hasChildren=true;this._running=true}this.resetTime();engine.start()}return this}restart(){return this.reset(0).play()}seek(time,muteCallbacks){reviveTimer(this);this.completed=false;const isPaused=this.paused;this.paused=true;tick(this,time+this._delay,~~muteCallbacks,0,tickModes.AUTO);return isPaused?this:this.play()}reverse(){const reversed=this.reversed;this.reversed=+(this._alternate&&!(this._iterationCount%2)?reversed:!reversed);this.seek(this.duration-this.currentTime);this.resetTime();return this}playForward(){return this.reversed?this.reverse().play():this.play()}playBackward(){return!this.reversed?this.reverse().play():this.play()}cancel(){if(this._hasChildren){forEachChildren(this,(child=>child.cancel()),true)}else{forEachChildren(this,removeTweenSliblings)}this._cancelled=1;return this.pause()}stretch(newDuration){const currentDuration=this.duration;if(currentDuration===newDuration)return this;const timeScale=newDuration/currentDuration;this.duration=clampZero(clampInfinity(currentDuration*timeScale));this._iterationDuration=clampZero(clampInfinity(this._iterationDuration*timeScale));this._offset*=timeScale;this._delay*=timeScale;this._loopDelay*=timeScale;return this}revert(){tick(this,0,1,0,tickModes.FORCE);const autoplay=this._autoplay;if(autoplay.linked)autoplay.revert();return this.cancel()}then(callback=noop){const then=this.then;const onResolve=()=>{this.then=null;callback(this);this.then=then;this._resolve=noop};return new Promise((r=>{this._resolve=()=>r(onResolve());if(this.completed)this._resolve();return this}))}}const cleanInlineStyles=renderable=>{if(renderable._hasChildren){forEachChildren(renderable,cleanInlineStyles,true)}else{const animation=renderable;animation.pause();forEachChildren(animation,(tween=>{const tweenProperty=tween.property;const tweenTarget=tween.target;if(tweenTarget[isDomSymbol]){const targetStyle=tweenTarget.style;const originalInlinedValue=animation._inlineStyles[tweenProperty];if(tween._tweenType===tweenTypes.TRANSFORM){const cachedTransforms=tweenTarget[transformsSymbol];if(isUnd(originalInlinedValue)||originalInlinedValue===emptyString){delete cachedTransforms[tweenProperty]}else{cachedTransforms[tweenProperty]=originalInlinedValue}if(tween._renderTransforms){if(!Object.keys(cachedTransforms).length){targetStyle.removeProperty("transform")}else{let str=emptyString;for(let key in cachedTransforms){str+=transformsFragmentStrings[key]+cachedTransforms[key]+") "}targetStyle.transform=str}}}else{if(isUnd(originalInlinedValue)||originalInlinedValue===emptyString){targetStyle.removeProperty(tweenProperty)}else{targetStyle[tweenProperty]=originalInlinedValue}}if(animation._tail===tween){animation.targets.forEach((t=>{if(t.getAttribute&&t.getAttribute("style")===emptyString){t.removeAttribute("style")}}))}}}))}return renderable};const fromTargetObject=createDecomposedValueTargetObject();const toTargetObject=createDecomposedValueTargetObject();const toFunctionStore={func:null};const keyframesTargetArray=[null];const fastSetValuesArray=[null,null];const keyObjectTarget={to:null};let tweenId=0;let keyframes;let key;const generateKeyframes=(keyframes,parameters)=>{const properties={};if(isArr(keyframes)){const propertyNames=[].concat(...keyframes.map((key=>Object.keys(key)))).filter(isKey);for(let i=0,l=propertyNames.length;i<l;i++){const propName=propertyNames[i];const propArray=keyframes.map((key=>{const newKey={};for(let p in key){const keyValue=key[p];if(isKey(p)){if(p===propName){newKey.to=keyValue}}else{newKey[p]=keyValue}}return newKey}));properties[propName]=propArray}}else{const totalDuration=setValue(parameters.duration,globals.defaults.duration);const keys=Object.keys(keyframes).map((key=>({o:parseFloat(key)/100,p:keyframes[key]}))).sort(((a,b)=>a.o-b.o));keys.forEach((key=>{const offset=key.o;const prop=key.p;for(let name in prop){if(isKey(name)){let propArray=properties[name];if(!propArray)propArray=properties[name]=[];const duration=offset*totalDuration;let length=propArray.length;let prevKey=propArray[length-1];const keyObj={to:prop[name]};let durProgress=0;for(let i=0;i<length;i++){durProgress+=propArray[i].duration}if(length===1){keyObj.from=prevKey.to}if(prop.ease){keyObj.ease=prop.ease}keyObj.duration=duration-(length?durProgress:0);propArray.push(keyObj)}}return key}));for(let name in properties){const propArray=properties[name];let prevEase;for(let i=0,l=propArray.length;i<l;i++){const prop=propArray[i];const currentEase=prop.ease;if(prevEase)prop.ease=prevEase;prevEase=currentEase}if(!propArray[0].duration){propArray.shift()}}}return properties};class Animation extends Timer{constructor(targets,parameters,parent,parentPosition,fastSet=false,index=0,length=0){super(parameters,parent,parentPosition);this._head=null;this._tail=null;const parsedTargets=registerTargets(targets);const targetsLength=parsedTargets.length;const kfParams=parameters.keyframes;const params=kfParams?mergeObjects(generateKeyframes(kfParams,parameters),parameters):parameters;const{delay:delay,duration:duration,ease:ease,playbackEase:playbackEase,modifier:modifier,composition:composition,onRender:onRender}=params;const animDefaults=parent?parent.defaults:globals.defaults;const animaPlaybackEase=setValue(playbackEase,animDefaults.playbackEase);const animEase=animaPlaybackEase?parseEasings(animaPlaybackEase):null;const hasSpringEasing=!isUnd(ease)&&isObj(ease);const tEasing=hasSpringEasing?ease.solver:setValue(ease,animEase?"linear":animDefaults.ease);const tDuration=hasSpringEasing?ease.duration:setValue(duration,animDefaults.duration);const tDelay=setValue(delay,animDefaults.delay);const tModifier=modifier||animDefaults.modifier;const tComposition=isUnd(composition)&&targetsLength>=K?compositionTypes.none:!isUnd(composition)?composition:animDefaults.composition;const animInlineStyles={};const animOffsetTime=this._offset;let iterationDuration=NaN;let iterationDelay=NaN;let animationAnimationLength=0;for(let targetIndex=0;targetIndex<targetsLength;targetIndex++){const target=parsedTargets[targetIndex];const ti=index||targetIndex;const tl=length||targetsLength;let lastTransformGroupIndex=NaN;let lastTransformGroupLength=NaN;for(let p in params){if(isKey(p)){const tweenType=getTweenType(target,p);if(tweenType!==tweenTypes.INVALID){const propName=sanitizePropertyName(p,target,tweenType);let propValue=params[p];if(fastSet){fastSetValuesArray[0]=propValue;fastSetValuesArray[1]=propValue;propValue=fastSetValuesArray}if(isArr(propValue)){const arrayLength=propValue.length;const isNotObjectValue=!isObj(propValue[0]);if(arrayLength===2&&isNotObjectValue){keyObjectTarget.to=propValue;keyframesTargetArray[0]=keyObjectTarget;keyframes=keyframesTargetArray}else if(arrayLength>2&&isNotObjectValue){keyframes=[];propValue.forEach(((v,i)=>{if(!i){fastSetValuesArray[0]=v}else if(i===1){fastSetValuesArray[1]=v;keyframes.push(fastSetValuesArray)}else{keyframes.push(v)}}))}else{keyframes=propValue}}else{keyframesTargetArray[0]=propValue;keyframes=keyframesTargetArray}let siblings=null;let prevTween=null;let firstTweenChangeStartTime=NaN;let lastTweenChangeEndTime=0;let tweenIndex=0;for(let l=keyframes.length;tweenIndex<l;tweenIndex++){const keyframe=keyframes[tweenIndex];if(isObj(keyframe)){key=keyframe}else{keyObjectTarget.to=keyframe;key=keyObjectTarget}toFunctionStore.func=null;const computedToValue=getFunctionValue(key.to,target,ti,tl,toFunctionStore);let tweenToValue;if(isObj(computedToValue)&&!isUnd(computedToValue.to)){key=computedToValue;tweenToValue=computedToValue.to}else{tweenToValue=computedToValue}const tweenFromValue=getFunctionValue(key.from,target,ti,tl);const keyEasing=key.ease;const hasSpringEasing=!isUnd(keyEasing)&&isObj(keyEasing);const tweenEasing=hasSpringEasing?keyEasing.solver:keyEasing||tEasing;const tweenDuration=hasSpringEasing?keyEasing.duration:getFunctionValue(setValue(key.duration,l>1?getFunctionValue(tDuration,target,ti,tl)/l:tDuration),target,ti,tl);const tweenDelay=getFunctionValue(setValue(key.delay,!tweenIndex?tDelay:0),target,ti,tl);const computedComposition=getFunctionValue(setValue(key.composition,tComposition),target,ti,tl);const tweenComposition=isNum(computedComposition)?computedComposition:compositionTypes[computedComposition];const tweenModifier=key.modifier||tModifier;const isFromToArray=isArr(tweenToValue);const isFromToValue=isFromToArray||!isUnd(tweenFromValue)&&!isUnd(tweenToValue);const tweenStartTime=prevTween?lastTweenChangeEndTime+tweenDelay:tweenDelay;const absoluteStartTime=animOffsetTime+tweenStartTime;let prevSibling=prevTween;if(tweenComposition!==compositionTypes.none){if(!siblings)siblings=getTweenSiblings(target,propName);let nextSibling=siblings._head;while(nextSibling&&!nextSibling._isOverridden&&nextSibling._absoluteStartTime<=absoluteStartTime){prevSibling=nextSibling;nextSibling=nextSibling._nextRep;if(nextSibling&&nextSibling._absoluteStartTime>=absoluteStartTime){while(nextSibling){overrideTween(nextSibling);nextSibling=nextSibling._nextRep}}}}if(isFromToValue){decomposeRawValue(isFromToArray?getFunctionValue(tweenToValue[0],target,ti,tl):tweenFromValue,fromTargetObject);decomposeRawValue(isFromToArray?getFunctionValue(tweenToValue[1],target,ti,tl,toFunctionStore):tweenToValue,toTargetObject);if(fromTargetObject.t===valueTypes.NUMBER){if(prevSibling){if(prevSibling._valueType===valueTypes.UNIT){fromTargetObject.t=valueTypes.UNIT;fromTargetObject.u=prevSibling._unit}}else{decomposeRawValue(getOriginalAnimatableValue(target,propName,tweenType,animInlineStyles),decomposedOriginalValue);if(decomposedOriginalValue.t===valueTypes.UNIT){fromTargetObject.t=valueTypes.UNIT;fromTargetObject.u=decomposedOriginalValue.u}}}}else{if(!isUnd(tweenToValue)){decomposeRawValue(tweenToValue,toTargetObject)}else{if(prevTween){decomposeTweenValue(prevTween,toTargetObject)}else{decomposeRawValue(parent&&prevSibling&&prevSibling.parent.parent===parent?prevSibling._value:getOriginalAnimatableValue(target,propName,tweenType,animInlineStyles),toTargetObject)}}if(!isUnd(tweenFromValue)){decomposeRawValue(tweenFromValue,fromTargetObject)}else{if(prevTween){decomposeTweenValue(prevTween,fromTargetObject)}else{decomposeRawValue(parent&&prevSibling&&prevSibling.parent.parent===parent?prevSibling._value:getOriginalAnimatableValue(target,propName,tweenType,animInlineStyles),fromTargetObject)}}}if(fromTargetObject.o){fromTargetObject.n=getRelativeValue(!prevSibling?decomposeRawValue(getOriginalAnimatableValue(target,propName,tweenType,animInlineStyles),decomposedOriginalValue).n:prevSibling._toNumber,fromTargetObject.n,fromTargetObject.o)}if(toTargetObject.o){toTargetObject.n=getRelativeValue(fromTargetObject.n,toTargetObject.n,toTargetObject.o)}if(fromTargetObject.t!==toTargetObject.t){if(fromTargetObject.t===valueTypes.COMPLEX||toTargetObject.t===valueTypes.COMPLEX){const complexValue=fromTargetObject.t===valueTypes.COMPLEX?fromTargetObject:toTargetObject;const notComplexValue=fromTargetObject.t===valueTypes.COMPLEX?toTargetObject:fromTargetObject;notComplexValue.t=valueTypes.COMPLEX;notComplexValue.s=cloneArray(complexValue.s);notComplexValue.d=complexValue.d.map((()=>notComplexValue.n))}else if(fromTargetObject.t===valueTypes.UNIT||toTargetObject.t===valueTypes.UNIT){const unitValue=fromTargetObject.t===valueTypes.UNIT?fromTargetObject:toTargetObject;const notUnitValue=fromTargetObject.t===valueTypes.UNIT?toTargetObject:fromTargetObject;notUnitValue.t=valueTypes.UNIT;notUnitValue.u=unitValue.u}else if(fromTargetObject.t===valueTypes.COLOR||toTargetObject.t===valueTypes.COLOR){const colorValue=fromTargetObject.t===valueTypes.COLOR?fromTargetObject:toTargetObject;const notColorValue=fromTargetObject.t===valueTypes.COLOR?toTargetObject:fromTargetObject;notColorValue.t=valueTypes.COLOR;notColorValue.s=colorValue.s;notColorValue.d=[0,0,0,1]}}if(fromTargetObject.u!==toTargetObject.u){let valueToConvert=toTargetObject.u?fromTargetObject:toTargetObject;valueToConvert=convertValueUnit(target,valueToConvert,toTargetObject.u?toTargetObject.u:fromTargetObject.u,false)}if(toTargetObject.d&&fromTargetObject.d&&toTargetObject.d.length!==fromTargetObject.d.length){const longestValue=fromTargetObject.d.length>toTargetObject.d.length?fromTargetObject:toTargetObject;const shortestValue=longestValue===fromTargetObject?toTargetObject:fromTargetObject;shortestValue.d=longestValue.d.map(((_,i)=>isUnd(shortestValue.d[i])?0:shortestValue.d[i]));shortestValue.s=cloneArray(longestValue.s)}const tweenUpdateDuration=+tweenDuration||minValue;const tween={parent:this,id:tweenId++,property:propName,target:target,_value:null,_func:toFunctionStore.func,_ease:parseEasings(tweenEasing),_fromNumbers:cloneArray(fromTargetObject.d),_toNumbers:cloneArray(toTargetObject.d),_strings:cloneArray(toTargetObject.s),_fromNumber:fromTargetObject.n,_toNumber:toTargetObject.n,_numbers:cloneArray(fromTargetObject.d),_number:fromTargetObject.n,_unit:toTargetObject.u,_modifier:tweenModifier,_currentTime:0,_startTime:tweenStartTime,_delay:+tweenDelay,_updateDuration:tweenUpdateDuration,_changeDuration:tweenUpdateDuration,_absoluteStartTime:absoluteStartTime,_tweenType:tweenType,_valueType:toTargetObject.t,_composition:tweenComposition,_isOverlapped:0,_isOverridden:0,_renderTransforms:0,_prevRep:null,_nextRep:null,_prevAdd:null,_nextAdd:null,_prev:null,_next:null};if(tweenComposition!==compositionTypes.none){composeTween(tween,siblings)}if(isNaN(firstTweenChangeStartTime)){firstTweenChangeStartTime=tween._startTime}lastTweenChangeEndTime=tweenStartTime+tweenUpdateDuration;prevTween=tween;animationAnimationLength++;addChild(this,tween)}if(isNaN(iterationDelay)||firstTweenChangeStartTime<iterationDelay){iterationDelay=firstTweenChangeStartTime}if(isNaN(iterationDuration)||lastTweenChangeEndTime>iterationDuration){iterationDuration=lastTweenChangeEndTime}if(tweenType===tweenTypes.TRANSFORM){lastTransformGroupIndex=animationAnimationLength-tweenIndex;lastTransformGroupLength=animationAnimationLength}}}}if(!isNaN(lastTransformGroupIndex)){let i=0;forEachChildren(this,(tween=>{if(i>=lastTransformGroupIndex&&i<lastTransformGroupLength){tween._renderTransforms=1;if(tween._composition===compositionTypes.blend){forEachChildren(additive.animation,(additiveTween=>{if(additiveTween.id===tween.id){additiveTween._renderTransforms=1}}))}}i++}))}}if(!targetsLength){console.warn(`No target found. Make sure the element you're trying to animate is accessible before creating your animation.`)}if(iterationDelay){forEachChildren(this,(tween=>{if(!(tween._startTime-tween._delay)){tween._delay-=iterationDelay}tween._startTime-=iterationDelay}));iterationDuration-=iterationDelay}else{iterationDelay=0}if(!iterationDuration){iterationDuration=minValue;this._iterationCount=0}this.targets=parsedTargets;this.duration=clampInfinity((iterationDuration+this._loopDelay)*this._iterationCount-this._loopDelay)||minValue;this.onRender=onRender||animDefaults.onRender;this._ease=animEase;this._delay=iterationDelay;this._iterationDuration=iterationDuration;this._inlineStyles=animInlineStyles}stretch(newDuration){const currentDuration=this.duration;if(currentDuration===newDuration)return this;const timeScale=newDuration/currentDuration;forEachChildren(this,(tween=>{tween._updateDuration=clampZero(tween._updateDuration*timeScale);tween._changeDuration=clampZero(tween._changeDuration*timeScale);tween._currentTime*=timeScale;tween._startTime*=timeScale;tween._absoluteStartTime*=timeScale}));return super.stretch(newDuration)}refresh(){forEachChildren(this,(tween=>{const ogValue=getOriginalAnimatableValue(tween.target,tween.property,tween._tweenType);decomposeRawValue(ogValue,decomposedOriginalValue);tween._fromNumbers=cloneArray(decomposedOriginalValue.d);tween._fromNumber=decomposedOriginalValue.n;if(tween._func){decomposeRawValue(tween._func(),toTargetObject);tween._toNumbers=cloneArray(toTargetObject.d);tween._strings=cloneArray(toTargetObject.s);tween._toNumber=toTargetObject.n}}));return this}revert(){super.revert();return cleanInlineStyles(this)}then(callback){return super.then(callback)}}function getTargetValue(targetSelector,propName,unit){const targets=registerTargets(targetSelector);if(isNil(targets)||isArr(targets)&&!targets.length)return;if(targets&&targets.length){const[target]=targets;const tweenType=getTweenType(target,propName);const normalizePropName=sanitizePropertyName(propName,target,tweenType);let originalValue=getOriginalAnimatableValue(target,normalizePropName);if(isUnd(unit)){return originalValue}else{decomposeRawValue(originalValue,decomposedOriginalValue);if(decomposedOriginalValue.t===valueTypes.NUMBER||decomposedOriginalValue.t===valueTypes.UNIT){if(unit===false){return decomposedOriginalValue.n}else{const convertedValue=convertValueUnit(target,decomposedOriginalValue,unit,false);return`${round(convertedValue.n,3)}${convertedValue.u}`}}}}}const setTargetValues=(targets,parameters)=>{if(isUnd(parameters))return;parameters.duration=minValue;parameters.composition=setValue(parameters.composition,compositionTypes.none);return new Animation(targets,parameters,null,0,true).play()};const removeTargetsFromAnimation=(targetsArray,animation)=>{let tweensMatchesTargets=false;forEachChildren(animation,(tween=>{if(targetsArray.includes(tween.target)){removeChild(animation,tween);tweensMatchesTargets=true}}),true);return tweensMatchesTargets};const remove=(targets,parent)=>{const targetsArray=parseTargets(targets);const parentClock=parent?parent:engine;let removeMatches;if(parentClock._hasChildren){forEachChildren(parentClock,(child=>{if(!child._hasChildren){removeMatches=removeTargetsFromAnimation(targetsArray,child);if(removeMatches&&!child._head)removeChild(parentClock,child)}if(child._head){remove(targets,child)}else{child._hasChildren=false}}),true)}else{removeMatches=removeTargetsFromAnimation(targetsArray,parentClock)}if(removeMatches&&!parentClock._head){parentClock._hasChildren=false;const pausableTimer=parentClock;if(pausableTimer.pause)pausableTimer.pause()}return targetsArray};const random=(min,max,decimalLength)=>{const m=10**(decimalLength||0);return floor((Math.random()*(max-min+1/m)+min)*m)/m};const randomPick=items=>items[random(0,items.length-1)];const shuffle=items=>{let m=items.length-1,t,i;while(m){i=random(0,m--);t=items[m];items[m]=items[i];items[i]=t}return items};const roundPad=(v,decimalLength)=>(+v).toFixed(decimalLength);const padStart=(v,totalLength,padString)=>`${v}`.padStart(totalLength,padString);const padEnd=(v,totalLength,padString)=>`${v}`.padEnd(totalLength,padString);const wrap=(v,min,max)=>((v-min)%(max-min)+(max-min))%(max-min)+min;const mapRange=(value,inLow,inHigh,outLow,outHigh)=>outLow+(value-inLow)/(inHigh-inLow)*(outHigh-outLow);const degToRad=degrees=>degrees*PI/180;const radToDeg=radians=>radians*180/PI;const lerp=(start,end,amount,renderable)=>{let dt=K/globals.defaults.frameRate;if(renderable!==false){const ticker=renderable||engine._hasChildren&&engine;if(ticker&&ticker.deltaTime){dt=ticker.deltaTime}}const t=1-Math.exp(-amount*dt*.1);return!amount?start:amount===1?end:(1-t)*start+t*end};const curry=(fn,last=0)=>(...args)=>last?v=>fn(...args,v):v=>fn(v,...args);const chain=fn=>(...args)=>{const result=fn(...args);return new Proxy(noop,{apply:(_,__,[v])=>result(v),get:(_,prop)=>chain(((...nextArgs)=>{const nextResult=utils[prop](...nextArgs);return v=>nextResult(result(v))}))})};const makeChainable=(fn,right=0)=>(...args)=>(args.length<fn.length?chain(curry(fn,right)):fn)(...args);const utils={$:registerTargets,get:getTargetValue,set:setTargetValues,remove:remove,cleanInlineStyles:cleanInlineStyles,random:random,randomPick:randomPick,shuffle:shuffle,lerp:lerp,clamp:makeChainable(clamp),round:makeChainable(round),snap:makeChainable(snap),wrap:makeChainable(wrap),interpolate:makeChainable(interpolate,1),mapRange:makeChainable(mapRange),roundPad:makeChainable(roundPad),padStart:makeChainable(padStart),padEnd:makeChainable(padEnd),degToRad:makeChainable(degToRad),radToDeg:makeChainable(radToDeg)};const springsCache=new Map;const spring=(mass=1,stiffness=100,damping=10,velocity=0)=>{const parameters=[mass,stiffness,damping,velocity];let springEasing=springsCache.get(parameters);if(!springEasing){const m=clamp(mass,0,K);const s=clamp(stiffness,1,K);const d=clamp(damping,.1,K);const w0=clamp(sqrt(s/m),minValue,K);const zeta=d/(2*sqrt(s*m));const wd=zeta<1?w0*sqrt(1-zeta*zeta):0;const b=zeta<1?(zeta*w0+-velocity)/wd:-velocity+w0;const step=K/60/100;const threshold=1e-4;const solver=t=>{if(zeta<1){t=exp(-t*zeta*w0)*(1*cos(wd*t)+b*sin(wd*t))}else{t=(1+b*t)*exp(-t*w0)}return 1-t};const duration=(()=>{let time=0;while(true){if(abs(1-solver(time))<threshold){const restStart=time;let restSteps=1;while(true){time+=step;if(abs(1-solver(time))>=threshold)break;restSteps++;if(restSteps===16)return restStart}}time+=step}})();springEasing={duration:round(duration*K,0),solver:t=>round(solver(duration*t),5)};springsCache.set(parameters,springEasing)}return springEasing};const getPrevChildOffset=(timeline,timePosition)=>{if(stringStartsWith(timePosition,"<")){const goToPrevAnimationOffset=timePosition[1]==="<";const prevAnimation=timeline._tail;const prevOffset=prevAnimation?prevAnimation._offset+prevAnimation._delay:0;return goToPrevAnimationOffset?prevOffset:prevOffset+prevAnimation.duration}};const parseTimelinePosition=(timeline,timePosition)=>{let tlDuration=timeline._iterationDuration;if(tlDuration===minValue)tlDuration=0;if(isUnd(timePosition))return tlDuration;if(isNum(+timePosition))return+timePosition;const timePosStr=timePosition;const tlLabels=timeline?timeline.labels:null;const hasLabels=!isNil(tlLabels);const prevOffset=getPrevChildOffset(timeline,timePosStr);const hasSibling=!isUnd(prevOffset);const matchedRelativeOperator=relativeValuesExecRgx.exec(timePosStr);if(matchedRelativeOperator){const fullOperator=matchedRelativeOperator[0];const split=timePosStr.split(fullOperator);const labelOffset=hasLabels&&split[0]?tlLabels[split[0]]:tlDuration;const parsedOffset=hasSibling?prevOffset:hasLabels?labelOffset:tlDuration;const parsedNumericalOffset=+split[1];return getRelativeValue(parsedOffset,parsedNumericalOffset,fullOperator[0])}else{return hasSibling?prevOffset:hasLabels?!isUnd(tlLabels[timePosStr])?tlLabels[timePosStr]:tlDuration:tlDuration}};function addTlChild(childParams,tl,parsedTLPosition,targets,index,length){const TLPosition=isNum(childParams.duration)&&childParams.duration<=minValue?parsedTLPosition-minValue:parsedTLPosition;tick(tl,TLPosition,1,1,tickModes.AUTO);const tlChild=targets?new Animation(targets,childParams,tl,TLPosition,false,index,length):new Timer(childParams,tl,TLPosition);tlChild.init(1);addChild(tl,tlChild);forEachChildren(tl,(child=>{const childTLOffset=child._offset+child._delay;const childDur=childTLOffset+child.duration;if(childDur>tl._iterationDuration){tl._iterationDuration=childDur}}));tl.duration=clampInfinity((tl._iterationDuration+tl._loopDelay)*tl._iterationCount-tl._loopDelay);return tl}class Timeline extends Timer{constructor(parameters={}){super(parameters,null,0);this.duration=0;this.labels={};const defaultsParams=parameters.defaults;const globalDefaults=globals.defaults;this.defaults=defaultsParams?mergeObjects(defaultsParams,globalDefaults):globalDefaults;this.onRender=parameters.onRender||globalDefaults.onRender;const tlPlaybackEase=setValue(parameters.playbackEase,globalDefaults.playbackEase);this._ease=tlPlaybackEase?parseEasings(tlPlaybackEase):null;this._iterationDuration=0;this._head=null;this._tail=null}add(a1,a2,a3){const isAnim=isObj(a2);const isTimer=isObj(a1);const isFunc=isFnc(a1);if(isAnim||isTimer||isFunc){this._hasChildren=true;if(isAnim){const childParams=a2;if(isFnc(a3)){const staggeredPosition=a3;const parsedTargetsArray=parseTargets(a1);const tlDuration=this.duration;const tlIterationDuration=this._iterationDuration;const id=childParams.id;let i=0;const parsedLength=parsedTargetsArray.length;parsedTargetsArray.forEach((target=>{const staggeredChildParams={...childParams};this.duration=tlDuration;this._iterationDuration=tlIterationDuration;if(!isUnd(id))staggeredChildParams.id=id+"-"+i;addTlChild(staggeredChildParams,this,staggeredPosition(target,i,parsedLength,this),target,i,parsedLength);i++}))}else{addTlChild(childParams,this,parseTimelinePosition(this,a3),a1)}}else{addTlChild(isTimer?a1:{onComplete:a1,duration:minValue},this,parseTimelinePosition(this,a2))}this.init(1);return this._autoplay?this.play():this}else if(isStr(a1)){this.labels[a1]=parseTimelinePosition(this,a2);return this}}set(targets,parameters,position){if(isUnd(parameters))return this;parameters.duration=minValue;parameters.composition=compositionTypes.replace;return this.add(targets,parameters,position)}stretch(newDuration){const currentDuration=this.duration;if(currentDuration===newDuration)return this;const timeScale=newDuration/currentDuration;const labels=this.labels;forEachChildren(this,(child=>{child.stretch(child.duration*timeScale)}));for(let labelName in labels){labels[labelName]*=timeScale}return super.stretch(newDuration)}refresh(){forEachChildren(this,(child=>{child.refresh()}));return this}revert(){super.revert();forEachChildren(this,(child=>child.revert),true);return cleanInlineStyles(this)}then(callback){return super.then(callback)}}const stagger=(val,params={})=>{let values=[];let maxValue=0;const from=params.from;const reversed=params.reversed;const ease=params.ease;const hasEasing=!isUnd(ease);const hasSpring=hasEasing?isObj(ease):false;const staggerEase=hasSpring?ease.solver:hasEasing?parseEasings(ease):null;const grid=params.grid;const axis=params.axis;const fromFirst=isUnd(from)||from===0||from==="first";const fromCenter=from==="center";const fromLast=from==="last";const isRange=isArr(val);const val1=isRange?parseNumber(val[0]):parseNumber(val);const val2=isRange?parseNumber(val[1]):0;const unitMatch=unitsExecRgx.exec(isRange?val[1]:val);const start=params.start||0+(isRange?val1:0);let fromIndex=fromFirst?0:isNum(from)?from:0;return(_,i,t,tl)=>{if(fromCenter)fromIndex=(t-1)/2;if(fromLast)fromIndex=t-1;if(!values.length){for(let index=0;index<t;index++){if(!grid){values.push(abs(fromIndex-index))}else{const fromX=!fromCenter?fromIndex%grid[0]:(grid[0]-1)/2;const fromY=!fromCenter?floor(fromIndex/grid[0]):(grid[1]-1)/2;const toX=index%grid[0];const toY=floor(index/grid[0]);const distanceX=fromX-toX;const distanceY=fromY-toY;let value=sqrt(distanceX*distanceX+distanceY*distanceY);if(axis==="x")value=-distanceX;if(axis==="y")value=-distanceY;values.push(value)}maxValue=max(...values)}if(staggerEase)values=values.map((val=>staggerEase(val/maxValue)*maxValue));if(reversed)values=values.map((val=>axis?val<0?val*-1:-val:abs(maxValue-val)))}const spacing=isRange?(val2-val1)/maxValue:val1;const offset=tl?parseTimelinePosition(tl,isUnd(params.start)?tl._iterationDuration:start):start;let output=offset+(spacing*round(values[i],2)||0);if(params.modifier)output=params.modifier(output);if(unitMatch)output=`${output}${unitMatch[2]}`;return output}};const getMaxViewHeight=()=>{const $el=document.createElement("div");doc.body.appendChild($el);$el.style.height="100lvh";const height=$el.offsetHeight;doc.body.removeChild($el);return height};const parseFunctionValue=(value,scroller)=>value&&isFnc(value)?value(scroller):value;const scrollContainers=new Map;class ScrollContainer{constructor($el){this.element=$el;this.useWin=this.element===doc.body;this.winWidth=0;this.winHeight=0;this.width=0;this.height=0;this.left=0;this.top=0;this.scrollX=0;this.scrollY=0;this.prevScrollX=0;this.prevScrollY=0;this.scrollWidth=0;this.scrollHeight=0;this.velocity=0;this.backwardX=false;this.backwardY=false;this.scrollTicker=new Timer({autoplay:false,onBegin:()=>this.dataTimer.play(),onUpdate:()=>{forEachChildren(this,(child=>child.handleScroll()))},onComplete:()=>this.dataTimer.pause()}).init();this.dataTimer=new Timer({frameRate:30,autoplay:false,onUpdate:self=>{const dt=self.deltaTime;const px=this.prevScrollX;const py=this.prevScrollY;const nx=this.scrollX;const ny=this.scrollY;const dx=px-nx;const dy=py-ny;this.prevScrollX=nx;this.prevScrollY=ny;if(dx)this.backwardX=px>nx;if(dy)this.backwardY=py>ny;this.velocity=dt>0?Math.sqrt(dx*dx+dy*dy)/dt:0}}).init();this.resizeTicker=new Timer({duration:250,onComplete:()=>{const winWidth=this.winWidth;const winHeight=this.winHeight;this.updateWindowBounds();if(winWidth!==this.winWidth||winHeight!==this.winHeight){this.refreshScrollers();this.handleScroll()}}});this.wakeTicker=new Timer({duration:66,onBegin:self=>{this.scrollTicker.play()},onComplete:()=>{this.scrollTicker.pause()}}).init();this._head=null;this._tail=null;this.updateScrollCoords();this.updateWindowBounds();this.updateBounds();(this.useWin?win:this.element).addEventListener("scroll",this,false);win.addEventListener("resize",this,false)}updateScrollCoords(){const useWin=this.useWin;const $el=this.element;this.scrollX=round(useWin?win.scrollX:$el.scrollLeft,0);this.scrollY=round(useWin?win.scrollY:$el.scrollTop,0)}updateWindowBounds(){this.winWidth=win.innerWidth;this.winHeight=getMaxViewHeight()}updateBounds(){const style=getComputedStyle(this.element);const $el=this.element;this.scrollWidth=$el.scrollWidth+parseFloat(style.marginLeft)+parseFloat(style.marginRight);this.scrollHeight=$el.scrollHeight+parseFloat(style.marginTop)+parseFloat(style.marginBottom);this.updateWindowBounds();let width,height;if(this.useWin){width=this.winWidth;height=this.winHeight}else{const elRect=$el.getBoundingClientRect();width=elRect.width;height=elRect.height;this.top=elRect.top;this.left=elRect.left}this.width=width;this.height=height}refreshScrollers(){forEachChildren(this,(child=>{if(child._debug){child.removeDebug()}}));this.updateBounds();forEachChildren(this,(child=>{child.refresh();if(child._debug){child.debug()}}))}refresh(){this.updateWindowBounds();this.updateBounds();this.refreshScrollers();this.handleScroll()}handleScroll(){this.updateScrollCoords();this.wakeTicker.restart()}handleResize(){this.resizeTicker.restart()}handleEvent(e){switch(e.type){case"scroll":this.handleScroll();break;case"resize":this.handleResize();break}}revert(){if(!this._head){this.scrollTicker.cancel();this.dataTimer.cancel();this.resizeTicker.cancel();this.wakeTicker.cancel();(this.useWin?win:this.element).removeEventListener("scroll",this);win.removeEventListener("resize",this);scrollContainers.delete(this.element)}}}const registerAndGetScrollContainer=target=>{const $el=target?parseTargets(target)[0]||doc.body:doc.body;let scrollContainer=scrollContainers.get($el);if(!scrollContainer){scrollContainer=new ScrollContainer($el);scrollContainers.set($el,scrollContainer)}return scrollContainer};const convertValueToPx=($el,v,size,under,over)=>{const clampMin=v==="min";const clampMax=v==="max";const value=v==="top"||v==="left"||v==="start"||clampMin?0:v==="bottom"||v==="right"||v==="end"||clampMax?"100%":v==="center"?"50%":v;const{n:n,u:u}=decomposeRawValue(value,decomposedOriginalValue);let px=n;if(u==="%"){px=n/100*size}else if(u){px=convertValueUnit($el,decomposedOriginalValue,"px",true).n}if(clampMax&&under<0)px+=under;if(clampMin&&over>0)px+=over;return px};const parseBoundValue=($el,v,size,under,over)=>{let value;if(isStr(v)){const matchedOperator=relativeValuesExecRgx.exec(v);if(matchedOperator){const splitter=matchedOperator[0];const operator=splitter[0];const splitted=v.split(splitter);const clampMin=splitted[0]==="min";const clampMax=splitted[0]==="max";const valueAPx=convertValueToPx($el,splitted[0],size,under,over);const valueBPx=convertValueToPx($el,splitted[1],size,under,over);if(clampMin){const min=getRelativeValue(convertValueToPx($el,"min",size),valueBPx,operator);value=min<valueAPx?valueAPx:min}else if(clampMax){const max=getRelativeValue(convertValueToPx($el,"max",size),valueBPx,operator);value=max>valueAPx?valueAPx:max}else{value=getRelativeValue(valueAPx,valueBPx,operator)}}else{value=convertValueToPx($el,v,size,under,over)}}else{value=v}return round(value,0)};const getAnimationDomTarget=linked=>{let $linkedTarget;const linkedTargets=linked.targets;for(let i=0,l=linkedTargets.length;i<l;i++){const target=linkedTargets[i];if(target[isDomSymbol]){$linkedTarget=target;break}}return $linkedTarget};let scrollerId=0;const debugColors=["#FF4B4B","#FF971B","#FFC730","#F9F640","#7AFF5A","#18FF74","#17E09B","#3CFFEC","#05DBE9","#33B3F1","#638CF9","#C563FE","#FF4FCF","#F93F8A"];class Scroller{constructor(parameters){if(globals.scope)globals.scope.revertibles.push(this);const sync=setValue(parameters.sync,"play pause");const ease=sync?parseEasings(sync):null;const isLinear=sync&&(sync==="linear"||sync===none);const isEase=sync&&!(ease===none&&!isLinear);const isSmooth=sync&&(isNum(sync)||sync===true||isLinear);const isMethods=sync&&(isStr(sync)&&!isEase&&!isSmooth);const syncMethods=isMethods?sync.split(" ").map((m=>()=>{const linked=this.linked;return linked&&linked[m]?linked[m]():null})):null;const biDirSync=isMethods&&syncMethods.length>2;this.id=scrollerId++;this.container=registerAndGetScrollContainer(parameters.container);this.target=null;this.linked=null;this.repeat=null;this.horizontal=null;this.enter=null;this.leave=null;this.sync=isEase||isSmooth||!!syncMethods;this.syncEase=isEase?ease:null;this.syncSmooth=isSmooth?sync===true||isLinear?1:sync:null;this.onSyncEnter=syncMethods&&!biDirSync&&syncMethods[0]?syncMethods[0]:noop;this.onSyncLeave=syncMethods&&!biDirSync&&syncMethods[1]?syncMethods[1]:noop;this.onSyncEnterForward=syncMethods&&biDirSync&&syncMethods[0]?syncMethods[0]:noop;this.onSyncLeaveForward=syncMethods&&biDirSync&&syncMethods[1]?syncMethods[1]:noop;this.onSyncEnterBackward=syncMethods&&biDirSync&&syncMethods[2]?syncMethods[2]:noop;this.onSyncLeaveBackward=syncMethods&&biDirSync&&syncMethods[3]?syncMethods[3]:noop;this.onEnter=parameters.onEnter||noop;this.onLeave=parameters.onLeave||noop;this.onEnterForward=parameters.onEnterForward||noop;this.onLeaveForward=parameters.onLeaveForward||noop;this.onEnterBackward=parameters.onEnterBackward||noop;this.onLeaveBackward=parameters.onLeaveBackward||noop;this.onUpdate=parameters.onUpdate||noop;this.onSyncComplete=parameters.onSyncComplete||noop;this.completed=false;this.began=false;this.isInView=false;this.offset=0;this.offsetStart=0;this.offsetEnd=0;this.distance=0;this.coords=[0,0,0,0];this.debugElement=null;this._params=parameters;this._debug=setValue(parameters.debug,false);this._next=null;this._prev=null;addChild(this.container,this);const targetPram=this._params?this._params.target:null;requestAnimationFrame((()=>{this.target=targetPram?parseTargets(targetPram)[0]||doc.body:this.linked&&this.target?this.target:doc.body;this.refresh();if(this._debug)this.debug()}))}link(linked){if(linked){linked.pause();this.linked=linked;const params=this._params;if(!params||params&&!params.target){let $linkedTarget;if(!isUnd(linked.targets)){$linkedTarget=getAnimationDomTarget(linked)}else{forEachChildren(linked,(child=>{if(child.targets&&!$linkedTarget){$linkedTarget=getAnimationDomTarget(child)}}))}if($linkedTarget){this.target=$linkedTarget;this.refresh()}}}}get velocity(){return this.container.velocity}get backward(){return this.horizontal?this.container.backwardX:this.container.backwardY}get scroll(){return this.horizontal?this.container.scrollX:this.container.scrollY}get progress(){const p=(this.scroll-this.offsetStart)/this.distance;return p===Infinity||isNaN(p)?0:round(clamp(p,0,1),6)}refresh(){const params=this._params;this.repeat=setValue(parseFunctionValue(params.repeat,this),true);this.horizontal=setValue(parseFunctionValue(params.axis,this),"y")==="x";this.enter=setValue(parseFunctionValue(params.enter,this),"start end");this.leave=setValue(parseFunctionValue(params.leave,this),"end start");this.updateBounds();this.handleScroll()}removeDebug(){if(this.debugElement){this.debugElement.parentNode.removeChild(this.debugElement);this.debugElement=null}}debug(){this.removeDebug();const container=this.container;const isHori=this.horizontal;const $existingDebug=container.element.querySelector(":scope > .animejs-onscroll-debug");const $debug=doc.createElement("div");const $thresholds=doc.createElement("div");const $triggerss=doc.createElement("div");const labels=["target","target","enter","leave"];const color=debugColors[this.id%debugColors.length];const useWin=container.useWin;const containerWidth=useWin?container.winWidth:container.width;const containerHeight=useWin?container.winHeight:container.height;const scrollWidth=container.scrollWidth;const scrollHeight=container.scrollHeight;const size=160;const offLeft=isHori?0:10;const offTop=isHori?10:0;const half=isHori?24:size/2;const labelHeight=isHori?half:15;const labelWidth=isHori?40:half;const labelSize=isHori?labelWidth:labelHeight;const repeat=isHori?"repeat-x":"repeat-y";const gradientOffset=v=>isHori?"-1px "+v+"px":v+"px"+" 0";const lineCSS=c=>`linear-gradient(${isHori?90:0}deg, ${c} 1px, transparent 1px)`;const baseCSS=(p,l,t,w,h)=>`position:${p};left:${l}px;top:${t}px;width:${w}px;height:${h}px;`;$debug.style.cssText=`${baseCSS("absolute",offLeft,offTop,isHori?scrollWidth:size,isHori?size:scrollHeight)}\n      pointer-events: none;\n      z-index: 1000000;\n      display: flex;\n      flex-direction: ${isHori?"column":"row"};\n    `;$thresholds.style.cssText=`${baseCSS("sticky",0,0,isHori?containerWidth:half,isHori?half:containerHeight)}`;if(!$existingDebug){$thresholds.style.cssText+=`background:\n        ${lineCSS("#A7A7A7")}${gradientOffset(half-8)} / ${isHori?"10px 8px":"8px 10px"} ${repeat},\n        ${lineCSS("#A7A7A7")}${gradientOffset(half-16)} / ${isHori?"100px 16px":"16px 100px"} ${repeat};\n      `}$triggerss.style.cssText=`${baseCSS("relative",0,0,isHori?scrollWidth:half,isHori?half:scrollHeight)}`;if(!$existingDebug){$triggerss.style.cssText+=`background:\n        ${lineCSS("#A7A7A7")}${gradientOffset(0)} / ${isHori?"10px 0px":"0px 10px"} ${repeat},\n        ${lineCSS("#A7A7A7")}${gradientOffset(0)} / ${isHori?"100px 8px":"8px 100px"} ${repeat};\n      `}this.coords.forEach(((v,i)=>{const isView=i>1;const value=(isView?0:this.offset)+v;const isTail=i%2;const isFirst=value<labelSize;const isOver=value>(isView?isHori?containerWidth:containerHeight:isHori?scrollWidth:scrollHeight)-labelSize;const isFlip=!isTail&&!isFirst||isOver;const $label=doc.createElement("div");const $text=doc.createElement("div");const dirProp=isHori?isFlip?"right":"left":isFlip?"bottom":"top";const flipOffset=isFlip?isHori?labelWidth:labelHeight:!isView?1:0;$text.innerHTML=`${labels[i]} ${isStr(this._debug)?this._debug:this.id}`;$label.style.cssText=`${baseCSS("absolute",0,0,labelWidth,labelHeight)}\n        display: flex;\n        flex-direction: ${isHori?"column":"row"};\n        justify-content: flex-${isView?"start":"end"};\n        align-items: flex-${isFlip?"end":"start"};\n        border-${dirProp}: 1px ${isTail?"solid":"solid"} ${color};\n      `;$text.style.cssText=`\n        overflow: hidden;\n        max-width: ${size/2-20}px;\n        height: ${labelHeight};\n        margin-${isHori?isFlip?"right":"left":isFlip?"bottom":"top"}: -1px;\n        padding: 1px;\n        font-family: ui-monospace, monospace;\n        font-size: 10px;\n        text-transform: uppercase;\n        line-height: 9px;\n        font-weight: bold;\n        text-align: ${isHori&&isFlip||!isHori&&!isView?"right":"left"};\n        white-space: pre;\n        text-overflow: ellipsis;\n        color: ${isTail?color:"rgba(0,0,0,.75)"};\n        background-color: ${isTail?"rgba(0,0,0,.65)":color};\n        border: 1px solid ${isTail?color:"transparent"};\n        border-${isHori?isFlip?"top-left":"top-right":isFlip?"top-left":"bottom-left"}-radius: 3px;\n        border-${isHori?isFlip?"bottom-left":"bottom-right":isFlip?"top-right":"bottom-right"}-radius: 3px;\n      `;$label.appendChild($text);$label.style[isHori?"left":"top"]=value-flipOffset+(!isFlip&&isFirst&&!isView?1:0)+"px";(isView?$thresholds:$triggerss).appendChild($label)}));$debug.appendChild($thresholds);$debug.appendChild($triggerss);container.element.appendChild($debug);if(!$existingDebug)$debug.classList.add("animejs-onscroll-debug");this.debugElement=$debug}updateBounds(){if(this._debug){this.removeDebug()}let stickys;const $target=this.target;const container=this.container;const isHori=this.horizontal;const linked=this.linked;let linkedTime;let $el=$target;let offset=0;if(linked){linkedTime=linked.currentTime;linked.seek(0,true)}while($el&&$el!==container.element&&$el!==doc.body){const isSticky=getTargetValue($el,"position")==="sticky"?setTargetValues($el,{position:"static"}):false;offset+=(isHori?$el.offsetLeft:$el.offsetTop)||0;$el=$el.offsetParent;if(isSticky){if(!stickys)stickys=[];stickys.push(isSticky)}}const targetSize=isHori?$target.offsetWidth:$target.offsetHeight;const containerSize=isHori?container.width:container.height;const scrollSize=isHori?container.scrollWidth:container.scrollHeight;const maxScroll=scrollSize-containerSize;const enter=this.enter;const leave=this.leave;let enterTarget="start";let leaveTarget="end";let enterContainer="end";let leaveContainer="start";if(isStr(enter)){const splitted=enter.split(" ");enterTarget=splitted[0];enterContainer=splitted.length>1?splitted[1]:splitted[0]}else if(isObj(enter)){const e=enter;if(!isUnd(e.target))enterTarget=e.target;if(!isUnd(e.container))enterContainer=e.container}else if(isNum(enter)){enterContainer=enter}if(isStr(leave)){const splitted=leave.split(" ");leaveTarget=splitted[0];leaveContainer=splitted.length>1?splitted[1]:splitted[0]}else if(isObj(leave)){const t=leave;if(!isUnd(t.target))leaveTarget=t.target;if(!isUnd(t.container))leaveContainer=t.container}else if(isNum(leave)){leaveContainer=leave}const parsedEnterTarget=parseBoundValue($target,enterTarget,targetSize);const parsedLeaveTarget=parseBoundValue($target,leaveTarget,targetSize);const under=parsedEnterTarget+offset-containerSize;const over=parsedLeaveTarget+offset-maxScroll;const parsedEnterContainer=parseBoundValue($target,enterContainer,containerSize,under,over);const parsedLeaveContainer=parseBoundValue($target,leaveContainer,containerSize,under,over);const offsetStart=parsedEnterTarget+offset-parsedEnterContainer;const offsetEnd=parsedLeaveTarget+offset-parsedLeaveContainer;const scrollDelta=offsetEnd-offsetStart;this.offset=offset;this.offsetStart=offsetStart;this.offsetEnd=offsetEnd;this.distance=scrollDelta<=0?0:scrollDelta;this.coords=[parsedEnterTarget,parsedLeaveTarget,parsedEnterContainer,parsedLeaveContainer];if(stickys){stickys.forEach((sticky=>sticky.revert()))}if(linked){linked.seek(linkedTime,true)}if(this._debug){this.debug()}}handleScroll(){const linked=this.linked;const sync=this.sync;const syncEase=this.syncEase;const syncSmooth=this.syncSmooth;const isHori=this.horizontal;const container=this.container;const scroll=this.scroll;const isBefore=scroll<=this.offsetStart;const isAfter=scroll>=this.offsetEnd;const isInView=!isBefore&&!isAfter;let hasUpdated=false;let syncCompleted=false;let p=this.progress;if(isBefore&&this.began){this.began=false}if(p>0&&!this.began){this.began=true}if(linked&&(syncEase||syncSmooth)){const ap=linked.progress;if(syncSmooth&&isNum(syncSmooth)){if(syncSmooth<1){const step=1e-4;const snap=ap<p&&p===1?step:ap>p&&!p?-step:0;p=round(lerp(ap,p,interpolate(.01,.2,syncSmooth),false)+snap,6)}}else if(syncEase){p=syncEase(p)}linked.seek(linked.duration*p);hasUpdated=p!==ap;syncCompleted=ap===1;if(hasUpdated&&!syncCompleted&&(syncSmooth&&ap)){container.wakeTicker.restart()}}if(this._debug&&this.debugElement){const sticky=isHori?container.scrollY:container.scrollX;this.debugElement.style[isHori?"top":"left"]=sticky+10+"px"}if(isInView){hasUpdated=true;if(!this.isInView){this.isInView=true;this.onSyncEnter(this);this.onEnter(this);if(this.backward){this.onSyncEnterBackward(this);this.onEnterBackward(this)}else{this.onSyncEnterForward(this);this.onEnterForward(this)}}}if(!isInView&&this.isInView){hasUpdated=true}if(hasUpdated){this.onUpdate(this)}if(!isInView&&this.isInView){this.isInView=false;this.onSyncLeave(this);this.onLeave(this);if(this.backward){this.onSyncLeaveBackward(this);this.onLeaveBackward(this)}else{this.onSyncLeaveForward(this);this.onLeaveForward(this)}if(sync&&!syncSmooth){syncCompleted=true}}if(p>=1&&this.began&&!this.completed&&(sync&&syncCompleted||!sync)){if(sync){this.onSyncComplete(this)}this.completed=true;if(!this.repeat&&!linked||!this.repeat&&linked&&linked.completed){this.revert()}}if(p<1&&this.completed){this.completed=false}}revert(){const container=this.container;removeChild(container,this);container.revert();if(this._debug){this.removeDebug()}}}const onScroll=(parameters={})=>new Scroller(parameters);class Animatable{constructor(targets,parameters){const globalParams={};const properties={};this.targets=[];this.animations={};if(isUnd(targets)||isUnd(parameters))return;for(let propName in parameters){const paramValue=parameters[propName];if(isKey(propName)){properties[propName]=paramValue}else{globalParams[propName]=paramValue}}for(let propName in properties){const propValue=properties[propName];const isObjValue=isObj(propValue);let propParams={};let to="+=0";if(isObjValue){const unit=propValue.unit;if(isStr(unit))to+=unit}else{propParams.duration=propValue}propParams[propName]=isObjValue?mergeObjects({to:to},propValue):to;const animParams=mergeObjects(globalParams,propParams);animParams.composition=compositionTypes.replace;animParams.autoplay=false;const animation=this.animations[propName]=new Animation(targets,animParams,null,0,false).init();if(!this.targets.length)this.targets.push(...animation.targets);this[propName]=(to,duration,ease)=>{const tween=animation._head;if(isUnd(to)){const numbers=tween._numbers;if(numbers&&numbers.length){return numbers}else{return tween._modifier(tween._number)}}else{forEachChildren(animation,(tween=>{if(isArr(to)){for(let i=0,l=to.length;i<l;i++){if(!isUnd(tween._numbers[i])){tween._fromNumbers[i]=tween._modifier(tween._numbers[i]);tween._toNumbers[i]=to[i]}}}else{tween._fromNumber=tween._modifier(tween._number);tween._toNumber=to}if(!isUnd(ease))tween._ease=parseEasings(ease);tween._currentTime=0}));if(!isUnd(duration))animation.stretch(duration);animation.seek(0,1).resetTime().play();return this}}}}revert(){for(let propName in this.animations){this[propName]=noop;this.animations[propName].revert()}this.animations={};this.targets.length=0}}class DOMProxy{constructor(el){this.el=el;this.zIndex=0;this.parentElement=null;this.classList={add:noop,remove:noop}}get x(){return this.el.x||0}set x(v){this.el.x=v}get y(){return this.el.y||0}set y(v){this.el.y=v}get width(){return this.el.width||0}set width(v){this.el.width=v}get height(){return this.el.height||0}set height(v){this.el.height=v}getBoundingClientRect(){return{top:this.y,right:this.x,bottom:this.y+this.height,left:this.x+this.width}}}class Transforms{constructor($el){this.$el=$el;this.inlineTransforms=[];this.point=new DOMPoint;this.inversedMatrix=this.getMatrix().inverse()}normalizePoint(x,y){this.point.x=x;this.point.y=y;return this.point.matrixTransform(this.inversedMatrix)}traverseUp(cb){let $el=this.$el.parentElement,i=0;while($el&&$el!==doc){cb($el,i);$el=$el.parentElement;i++}}getMatrix(){const matrix=new DOMMatrix;this.traverseUp(($el=>{const elMatrix=new DOMMatrix(getTargetValue($el,"transform"));matrix.preMultiplySelf(elMatrix)}));return matrix}remove(){this.traverseUp((($el,i)=>{this.inlineTransforms[i]=$el.style.transform;$el.style.transform="none"}))}revert(){this.traverseUp((($el,i)=>{const ct=this.inlineTransforms[i];if(ct===""){$el.style.removeProperty("transform")}else{$el.style.transform=ct}}))}}let zIndex=0;class Draggable{constructor(target,parameters={}){if(!target)return;if(globals.scope)globals.scope.revertibles.push(this);const animatableParams={};const paramX=parameters.x;const paramY=parameters.y;const trigger=parameters.trigger;const modifier=parameters.modifier;const container=parameters.container;const cp=parameters.containerPadding||0;const containerPadding=isArr(cp)?cp:[cp,cp,cp,cp];const ease=parameters.releaseEase;const xProp=isObj(paramX)&&!isUnd(paramX.mapTo)?paramX.mapTo:"x";const yProp=isObj(paramY)&&!isUnd(paramY.mapTo)?paramY.mapTo:"y";if(modifier)animatableParams.modifier=modifier;this.snapX=setValue(parameters.snap,0);this.snapY=setValue(parameters.snap,0);this.scrollSpeed=setValue(parameters.scrollSpeed,1.5);this.dragSpeed=setValue(parameters.dragSpeed,1);this.releaseEase=ease?parseEasings(ease):null;this.releaseStiffness=setValue(parameters.releaseStiffness,1);this.releaseVelocity=setValue(parameters.releaseVelocity,1);this.onGrab=parameters.onGrab||noop;this.onDrag=parameters.onDrag||noop;this.onRelease=parameters.onRelease||noop;this.onUpdate=parameters.onUpdate||noop;this.onSettle=parameters.onSettle||noop;this.onSnap=parameters.onSnap||noop;this.disabled=[0,0];this.containerPadding=setValue(containerPadding,[0,0,0,0]);this.containerFriction=clamp(0,setValue(parameters.containerFriction,.85),1);if(isUnd(paramX)||paramX===true){animatableParams[xProp]=0}else if(isObj(paramX)){const paramXObject=paramX;const animatableXParams={};if(paramXObject.modifier)animatableXParams.modifier=paramXObject.modifier;if(paramXObject.composition)animatableXParams.composition=paramXObject.composition;if(!isUnd(paramXObject.snap))this.snapX=paramXObject.snap;animatableParams[xProp]=animatableXParams}else if(paramX===false){animatableParams[xProp]=0;this.disabled[0]=1}if(isUnd(paramY)||paramY===true){animatableParams[yProp]=0}else if(isObj(paramY)){const paramYObject=paramY;const animatableYParams={};if(paramYObject.modifier)animatableYParams.modifier=paramYObject.modifier;if(paramYObject.composition)animatableYParams.composition=paramYObject.composition;if(!isUnd(paramYObject.snap))this.snapY=paramYObject.snap;animatableParams[yProp]=animatableYParams}else if(paramY===false){animatableParams[yProp]=0;this.disabled[1]=1}this.container=isArr(container)?container:null;this.$target=isObj(target)?new DOMProxy(target):parseTargets(target)[0];this.$trigger=parseTargets(trigger?trigger:target)[0];this.$container=container&&!this.container?parseTargets(container)[0]:doc.body;this.animatable=new Animatable(this.$target,animatableParams);this.x=this.animatable[xProp];this.y=this.animatable[yProp];this.destX=0;this.destY=0;this.scroll={x:0,y:0};this.coords=[this.x(),this.y()];this.snapped=[0,0];this.pointer=[0,0,0,0];this.scrollView=[0,0];this.dragArea=[0,0,0,0];this.containerBounds=[-maxValue,maxValue,maxValue,-maxValue];this.scrollBounds=[0,0,0,0];this.targetBounds=[0,0,0,0];this.window=[0,0];this.velocity=0;this.angle=0;this.touchActionStyles=setTargetValues(this.$trigger,{touchAction:"none"});this.triggerStyles=null;this.bodyStyles=null;this.targetStyles=null;this.transforms=new Transforms(this.$target);this.scrollThreshold=setValue(parameters.scrollThreshold,30);this.updateTicker=new Timer({autoplay:false,onUpdate:()=>this.update()},null,0).init();this.dragging=false;this.updated=false;this.released=false;this.contained=!isUnd(container);this.canScroll=false;this.useWin=this.$container===doc.body;this.$scrollContainer=this.useWin?win:this.$container;this.isFinePointer=matchMedia("(pointer:fine)").matches;this.enabled=false;this.animatable.animations[this.disabled[0]?yProp:xProp].onUpdate=()=>{if(this.dragging&&this.updated){this.onUpdate(this);this.onDrag(this);this.updated=false}if(this.released){this.onUpdate(this)}};this.animatable.animations[this.disabled[0]?yProp:xProp].then((()=>{if(this.released){this.onSettle(this);this.released=false}}));this.enable();this.updateBoundingValues()}setPosition(x,y,duration,ease){this.destX=x;this.destY=y;this.snapped[0]=snap(x,this.snapX);this.snapped[1]=snap(y,this.snapY);this.x(x,duration,ease);this.y(y,duration,ease)}updateScrollCoords(){const sx=round(this.useWin?win.scrollX:this.$container.scrollLeft,0);const sy=round(this.useWin?win.scrollY:this.$container.scrollTop,0);const[cpt,cpr,cpb,cpl]=this.containerPadding;this.scroll.x=sx;this.scroll.y=sy;this.scrollBounds[0]=sy-this.targetBounds[0]+cpt;this.scrollBounds[1]=sx-this.targetBounds[1]-cpr;this.scrollBounds[2]=sy-this.targetBounds[2]-cpb;this.scrollBounds[3]=sx-this.targetBounds[3]+cpl}updateBoundingValues(){const cx=this.x();const cy=this.y();const iw=this.window[0]=win.innerWidth;const ih=this.window[1]=win.innerHeight;const uw=this.useWin;const sw=this.$container.scrollWidth;const sh=this.$container.scrollHeight;const transformContainerRect=this.$container.getBoundingClientRect();const[cpt,cpr,cpb,cpl]=this.containerPadding;this.dragArea[0]=uw?0:transformContainerRect.left;this.dragArea[1]=uw?0:transformContainerRect.top;this.scrollView[0]=uw?clamp(sw,iw,sw):sw;this.scrollView[1]=uw?clamp(sh,ih,sh):sh;this.setPosition(0,0,0);this.transforms.remove();this.updateScrollCoords();const{width:width,height:height,left:left,top:top,right:right,bottom:bottom}=this.$container.getBoundingClientRect();this.dragArea[2]=round(uw?clamp(width,iw,iw):width,0);this.dragArea[3]=round(uw?clamp(height,ih,ih):height,0);this.canScroll=sw>this.dragArea[2]+cpl-cpr||sh>this.dragArea[3]+cpt-cpb&&!this.container&&this.contained;if(this.contained){const sx=this.scroll.x;const sy=this.scroll.y;const canScroll=this.canScroll;const targetRect=this.$target.getBoundingClientRect();const hiddenLeft=canScroll?uw?0:this.$container.scrollLeft:0;const hiddenTop=canScroll?uw?0:this.$container.scrollTop:0;const hiddenRight=canScroll?this.scrollView[0]-hiddenLeft-width:0;const hiddenBottom=canScroll?this.scrollView[1]-hiddenTop-height:0;this.targetBounds[0]=round(targetRect.top+sy-(uw?0:top),0);this.targetBounds[1]=round(targetRect.right+sx-(uw?iw:right),0);this.targetBounds[2]=round(targetRect.bottom+sy-(uw?ih:bottom),0);this.targetBounds[3]=round(targetRect.left+sx-(uw?0:left),0);if(this.container){this.containerBounds[0]=this.container[0]+cpt;this.containerBounds[1]=this.container[1]-cpr;this.containerBounds[2]=this.container[2]-cpb;this.containerBounds[3]=this.container[3]+cpl}else{this.containerBounds[0]=-round(targetRect.top-top+hiddenTop-cpt,0);this.containerBounds[1]=-round(targetRect.right-right-hiddenRight+cpr,0);this.containerBounds[2]=-round(targetRect.bottom-bottom-hiddenBottom+cpb,0);this.containerBounds[3]=-round(targetRect.left-left+hiddenLeft-cpl,0)}}const[bt,br,bb,bl]=this.containerBounds;this.transforms.revert();this.setPosition(clamp(cx,bl,br),clamp(cy,bt,bb),0)}isOutOfBounds(bounds,x,y){if(!this.contained)return false;const[bt,br,bb,bl]=bounds;const[dx,dy]=this.disabled;return!dx&&x<bl||!dx&&x>br||!dy&&y<bt||!dy&&y>bb}update(){this.updateScrollCoords();if(this.canScroll){const[cpt,cpr,cpb,cpl]=this.containerPadding;const[sw,sh]=this.scrollView;const daw=this.dragArea[2];const dah=this.dragArea[3];const csx=this.scroll.x;const csy=this.scroll.y;const nsw=this.$container.scrollWidth;const nsh=this.$container.scrollHeight;const csw=this.useWin?clamp(nsw,this.window[0],nsw):nsw;const csh=this.useWin?clamp(nsh,this.window[1],nsh):nsh;const swd=sw-csw;const shd=sh-csh;if(swd>0||shd>0){if(swd>0){this.coords[0]-=swd;this.scrollView[0]=csw}if(shd>0){this.coords[1]-=shd;this.scrollView[1]=csh}}else{const s=this.scrollSpeed*10;const treshold=this.scrollThreshold;const[x,y]=this.coords;const[st,sr,sb,sl]=this.scrollBounds;const t=round(clamp((y-st-treshold+cpt)/treshold,-1,0)*s,0);const r=round(clamp((x-sr+treshold-cpr)/treshold,0,1)*s,0);const b=round(clamp((y-sb+treshold-cpb)/treshold,0,1)*s,0);const l=round(clamp((x-sl-treshold+cpl)/treshold,-1,0)*s,0);if(t||b||l||r){const scrollX=round(clamp(csx+(l||r),0,sw-daw),0);const scrollY=round(clamp(csy+(t||b),0,sh-dah),0);this.coords[0]-=csx-scrollX;this.coords[1]-=csy-scrollY;this.$scrollContainer.scrollTo(scrollX,scrollY)}}}const[px,py]=this.pointer;this.coords[0]+=(px-this.pointer[2])*this.dragSpeed;this.coords[1]+=(py-this.pointer[3])*this.dragSpeed;this.pointer[2]=px;this.pointer[3]=py;const[nx,ny]=this.disabled;const[cx,cy]=this.coords;const[sx,sy]=this.snapped;const[ct,cr,cb,cl]=this.containerBounds;const cf=(1-this.containerFriction)*this.dragSpeed;this.setPosition(nx?this.x():cx>cr?cr+(cx-cr)*cf:cx<cl?cl+(cx-cl)*cf:cx,ny?this.y():cy>cb?cb+(cy-cb)*cf:cy<ct?ct+(cy-ct)*cf:cy,0);const[nsx,nsy]=this.snapped;if(nsx!==sx&&this.snapX||nsy!==sy&&this.snapY){this.onSnap(this)}}handleHover(){if(this.isFinePointer&&!this.triggerStyles){this.triggerStyles=setTargetValues(this.$trigger,{cursor:"grab"})}}handleDown(e){if(this.dragging)return;remove(this.scroll);const{x:x,y:y}=this.transforms.normalizePoint(e.clientX,e.clientY);this.dragging=true;this.updateBoundingValues();this.x(this.x(),0);this.y(this.y(),0);this.coords[0]=this.x();this.coords[1]=this.y();this.pointer[2]=x;this.pointer[3]=y;this.velocity=0;this.angle=0;if(this.targetStyles){this.targetStyles.revert();this.targetStyles=null}const z=getTargetValue(this.$target,"zIndex",false);zIndex=(z>zIndex?z:zIndex)+1;this.targetStyles=setTargetValues(this.$target,{zIndex:zIndex});if(this.isFinePointer){if(this.triggerStyles){this.triggerStyles.revert();this.targetStyles=null}this.bodyStyles=setTargetValues(doc.body,{cursor:"grabbing"})}doc.addEventListener("pointermove",this,false);doc.addEventListener("pointerup",this,false);doc.addEventListener("pointercancel",this,false);win.addEventListener("selectstart",this,false);this.onGrab(this)}handleMove(e){if(!this.dragging)return;e.preventDefault();if(!this.triggerStyles){this.triggerStyles=setTargetValues(this.$trigger,{pointerEvents:"none"})}const{x:x,y:y}=this.transforms.normalizePoint(e.clientX,e.clientY);const dt=this.updateTicker.play().deltaTime;const dx=x-this.pointer[2];const dy=y-this.pointer[3];this.velocity=dt>0?Math.sqrt(dx*dx+dy*dy)/dt:0;this.angle=Math.atan2(dy,dx);this.pointer[0]=x;this.pointer[1]=y;this.updated=true}handleUp(){if(!this.dragging)return;this.released=true;this.dragging=false;this.updateTicker.pause();if(this.triggerStyles){this.triggerStyles.revert();this.triggerStyles=null}if(this.isFinePointer&&this.bodyStyles){this.bodyStyles.revert();this.bodyStyles=null}const customEase=this.releaseEase;const ease=customEase?customEase:eases.out(5);const[bt,br,bb,bl]=this.containerBounds;const[sx,sy]=this.snapped;const cx=this.x();const cy=this.y();const rv=this.releaseVelocity;let destX=clamp(snap(cx,this.snapX),bl,br);let destY=clamp(snap(cy,this.snapY),bt,bb);let duration=650;if(this.isOutOfBounds(this.containerBounds,cx,cy)){this.setPosition(destX,destY,duration,ease)}else{const s=this.velocity;const cf=1-this.containerFriction;const ds=s*100*rv;const dx=s?Math.cos(this.angle)*ds:0;const dy=s?Math.sin(this.angle)*ds:0;const x=cx+dx;const y=cy+dy;const v=round(clamp(ds/50,0,20),2);const springEasing=spring(1,80*this.releaseStiffness,15,v);const springEase=springEasing.solver;duration=!rv?rv:springEasing.duration;destX=clamp(snap(x,this.snapX),bl,br);destY=clamp(snap(y,this.snapY),bt,bb);if(this.isOutOfBounds(this.containerBounds,x,y)&&cf){const bounceX=!this.disabled[0]&&(x>br||x<bl);const bounceY=!this.disabled[1]&&(y>bb||y<bt);const bx=bounceX&&!bounceY;const by=bounceY&&!bounceX;const bouncedX=by?clamp(destX+(destX-cx)*.25,bl,br):destX;const bouncedY=bx?clamp(destY+(destY-cy)*.25,bt,bb):destY;const easeX=by||customEase?ease:springEase;const easeY=bx||customEase?ease:springEase;destX=clamp(snap(bouncedX,this.snapX),bl,br);destY=clamp(snap(bouncedY,this.snapY),bt,bb);if(!this.disabled[0])this.x(destX,duration,easeX);if(!this.disabled[1])this.y(destY,duration,easeY)}else{if(!this.disabled[0])this.x(destX,duration*.6,ease);if(!this.disabled[1])this.y(destY,duration*.6,ease)}}if(!this.container&&this.isOutOfBounds(this.scrollBounds,destX,destY)){const[st,sr,sb,sl]=this.scrollBounds;const t=round(clamp(destY-st,-maxValue,0),0);const r=round(clamp(destX-sr,0,maxValue),0);const b=round(clamp(destY-sb,0,maxValue),0);const l=round(clamp(destX-sl,-maxValue,0),0);new Animation(this.scroll,{x:round(this.scroll.x+(l||r),0),y:round(this.scroll.y+(t||b),0),duration:duration*.75,ease:ease,onUpdate:()=>{this.$scrollContainer.scrollTo(this.scroll.x,this.scroll.y)}}).init()}this.destX=destX;this.destY=destY;this.onRelease(this);let hasSnapped=false;if(destX!==sx){this.snapped[0]=destX;if(this.snapX)hasSnapped=true}if(destY!==sy&&this.snapY){this.snapped[1]=destY;if(this.snapY)hasSnapped=true}if(hasSnapped)this.onSnap(this);doc.removeEventListener("pointermove",this);doc.removeEventListener("pointerup",this);doc.removeEventListener("pointercancel",this);win.removeEventListener("selectstart",this)}reset(){remove(this.scroll);this.dragging=false;this.setPosition(0,0,0);this.coords[0]=0;this.coords[1]=0;this.pointer[0]=0;this.pointer[1]=0;this.pointer[2]=0;this.pointer[3]=0;this.velocity=0;this.angle=0;return this}enable(){if(!this.enabled){this.enabled=true;this.$target.classList.remove("is-disabled");this.$trigger.addEventListener("pointerdown",this,false);this.$trigger.addEventListener("mouseenter",this,false)}return this}disable(){this.enabled=false;this.touchActionStyles.revert();if(this.triggerStyles){this.triggerStyles.revert();this.triggerStyles=null}if(this.bodyStyles){this.bodyStyles.revert();this.bodyStyles=null}if(this.targetStyles){this.targetStyles.revert();this.targetStyles=null}remove(this.scroll);this.updateTicker.pause();this.$target.classList.add("is-disabled");this.$trigger.removeEventListener("pointerdown",this);this.$trigger.removeEventListener("mouseenter",this);doc.removeEventListener("pointermove",this);doc.removeEventListener("pointerup",this);doc.removeEventListener("pointercancel",this);win.removeEventListener("selectstart",this);return this}revert(){this.reset();this.disable();this.$target.classList.remove("is-disabled");this.updateTicker.revert();return this}handleEvent(e){switch(e.type){case"pointerdown":this.handleDown(e);break;case"pointermove":this.handleMove(e);break;case"pointerup":this.handleUp();break;case"pointercancel":this.handleUp();break;case"mouseenter":this.handleHover();break;case"selectstart":e.preventDefault();break}}}class Scope{constructor(parameters={}){if(globals.scope)globals.scope.revertibles.push(this);const parsedRoot=parseTargets(parameters.root);const scopeDefaults=parameters.defaults;const globalDefault=globals.defaults;const mediaQueries=parameters.mediaQueries;this.defaults=scopeDefaults?mergeObjects(scopeDefaults,globalDefault):globalDefault;this.root=parsedRoot?parsedRoot[0]:doc;this.constructors=[];this.revertConstructors=[];this.revertibles=[];this.methods={};this.matches={};this.mediaQueryLists={};if(mediaQueries){for(let mq in mediaQueries){const _mq=win.matchMedia(mediaQueries[mq]);this.mediaQueryLists[mq]=_mq;_mq.addEventListener("change",this)}}}execute(cb){let activeScope=globals.scope;let activeRoot=globals.root;let activeDefaults=globals.defaults;globals.scope=this;globals.root=this.root;globals.defaults=this.defaults;const mqs=this.mediaQueryLists;for(let mq in mqs)this.matches[mq]=mqs[mq].matches;cb(this);globals.scope=activeScope;globals.root=activeRoot;globals.defaults=activeDefaults;return this}refresh(){this.execute((()=>{let i=this.revertibles.length;let y=this.revertConstructors.length;while(i--)this.revertibles[i].revert();while(y--)this.revertConstructors[y](this);this.revertibles.length=0;this.revertConstructors.length=0;this.constructors.forEach((constructor=>{const revertConstructor=constructor(this);if(revertConstructor){this.revertConstructors.push(revertConstructor)}}))}));return this}add(a1,a2){if(isFnc(a1)){const constructor=a1;this.constructors.push(constructor);this.execute((()=>{const revertConstructor=constructor(this);if(revertConstructor){this.revertConstructors.push(revertConstructor)}}))}else{this.methods[a1]=(...args)=>{this.execute((()=>a2(...args)))}}return this}handleEvent(e){switch(e.type){case"change":this.refresh();break}}revert(){const revertibles=this.revertibles;const reverts=this.revertConstructors;const mqs=this.mediaQueryLists;let i=revertibles.length;let y=reverts.length;while(i--)revertibles[i].revert();while(y--)reverts[y](this);for(let mq in mqs)mqs[mq].removeEventListener("change",this);revertibles.length=0;reverts.length=0;this.constructors.length=0;this.matches={};this.methods={};this.mediaQueryLists={}}}const createTimer=parameters=>new Timer(parameters,null,0).init();const animate=(targets,parameters)=>new Animation(targets,parameters,null,0,false).init();const createTimeline=parameters=>new Timeline(parameters).init();const createAnimatable=(targets,parameters)=>new Animatable(targets,parameters);const createDraggable=(target,parameters)=>new Draggable(target,parameters);const createScope=params=>new Scope(params);if(isBrowser){if(!win.AnimeJS)win.AnimeJS=[];win.AnimeJS.push({version:"4.0.0-beta.100.alpha-4",engine:engine});doc.addEventListener("visibilitychange",(()=>engine.suspendWhenHidden?doc.hidden?engine.suspend():engine.resume():0))}exports.Animatable=Animatable;exports.Animation=Animation;exports.Clock=Clock;exports.Draggable=Draggable;exports.Engine=Engine;exports.Scope=Scope;exports.Scroller=Scroller;exports.Timeline=Timeline;exports.Timer=Timer;exports.animate=animate;exports.createAnimatable=createAnimatable;exports.createDraggable=createDraggable;exports.createScope=createScope;exports.createTimeline=createTimeline;exports.createTimer=createTimer;exports.defaults=defaults;exports.eases=eases;exports.engine=engine;exports.onScroll=onScroll;exports.scrollContainers=scrollContainers;exports.spring=spring;exports.stagger=stagger;exports.svg=svg;exports.utils=utils}));
